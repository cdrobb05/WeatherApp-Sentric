"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2018 GoodData Corporation
// tslint:disable:member-ordering
var React = require("react");
var gooddata_js_1 = require("@gooddata/gooddata-js");
var typings_1 = require("@gooddata/typings");
var utils_1 = require("../helpers/utils");
var errorHandlers_1 = require("../helpers/errorHandlers");
var RuntimeError_1 = require("../errors/RuntimeError");
var conversion_1 = require("../helpers/conversion");
var bucketNames_1 = require("../constants/bucketNames");
var bucket_1 = require("../internal/constants/bucket");
var LoadingComponent_1 = require("../components/simple/LoadingComponent");
var ErrorComponent_1 = require("../components/simple/ErrorComponent");
exports.getExecutionFromDimensions = function (dimensions, filters, sorts) {
    var measuresBucket = {
        localIdentifier: bucketNames_1.MEASURES,
        items: [],
    };
    var attributesBucket = {
        localIdentifier: bucketNames_1.ATTRIBUTES,
        items: [],
    };
    var resultSpec = {
        dimensions: [],
        sorts: sorts,
    };
    var measureDimension = null;
    dimensions.forEach(function (dimension, dimensionIndex) {
        var itemIdentifiers = [];
        dimension.forEach(function (dimensionItem) {
            if (typings_1.VisualizationInput.isAttribute(dimensionItem)) {
                itemIdentifiers.push(dimensionItem.visualizationAttribute.localIdentifier);
                attributesBucket.items.push(dimensionItem);
            }
            else if (typings_1.VisualizationInput.isMeasure(dimensionItem)) {
                var measureLocalIdentifier = dimensionItem.measure.localIdentifier;
                if (measureDimension === null) {
                    measureDimension = dimensionIndex;
                    itemIdentifiers.push(bucket_1.MEASUREGROUP);
                }
                else if (measureDimension !== dimensionIndex) {
                    throw new RuntimeError_1.RuntimeError("All measures have to be on the same dimension. There are some measures already on dimension " + measureDimension + " but measure " + measureLocalIdentifier + " is on dimension " + dimensionIndex + ".");
                }
                measuresBucket.items.push(dimensionItem);
            }
        });
        resultSpec.dimensions.push({
            itemIdentifiers: itemIdentifiers,
        });
    });
    var buckets = [];
    if (attributesBucket.items.length > 0) {
        buckets.push(attributesBucket);
    }
    if (measuresBucket.items.length > 0) {
        buckets.push(measuresBucket);
    }
    if (buckets.length === 0) {
        throw new RuntimeError_1.RuntimeError("No measures nor attributes defined");
    }
    var afm = conversion_1.convertBucketsToAFM(buckets, filters);
    return {
        execution: {
            afm: afm,
            resultSpec: resultSpec,
        },
    };
};
var propsRequiringDataReset = [
    "projectId",
    "dimensions",
    "filters",
    "sortBy",
];
var propsRequiringStateUpdate = propsRequiringDataReset.concat(["children"]);
var didPropsChange = function (propList, prevProps, props) {
    return propList.some(function (propName) { return prevProps[propName] !== props[propName]; });
};
var setupSdk = function (props) {
    var clonedSdk = props.sdk ? props.sdk.clone() : gooddata_js_1.factory();
    utils_1.setTelemetryHeaders(clonedSdk, props.telemetryComponentName, props);
    return clonedSdk;
};
var BucketExecutor = /** @class */ (function (_super) {
    __extends(BucketExecutor, _super);
    function BucketExecutor(props) {
        var _this = _super.call(this, props) || this;
        _this.hasUnmounted = false;
        _this.getPage = function (paging) {
            var response = _this.state.response;
            if (_this.hasUnmounted) {
                // tslint:disable-next-line:no-console
                console.warn("You are calling a component that is already unmounted");
            }
            if (!response) {
                _this.getResponse(true, paging);
            }
            else {
                _this.getResult(response, paging);
            }
        };
        _this.getResponse = function (triggerGetResult, resultPaging) {
            if (triggerGetResult === void 0) { triggerGetResult = _this.props.autoLoadFirstPage; }
            if (resultPaging === void 0) { resultPaging = _this.getInitialPaging(); }
            var _a = _this.state, dimensions = _a.dimensions, filters = _a.filters, sortBy = _a.sortBy, projectId = _a.projectId;
            var execution = exports.getExecutionFromDimensions(dimensions, filters, sortBy);
            var responsePromise = _this.sdk.execution.getExecutionResponse(projectId, execution);
            _this.setState({
                result: null,
                response: null,
                isLoading: true,
                error: null,
                responsePromise: responsePromise,
            });
            responsePromise.then(function (response) {
                if (responsePromise !== _this.state.responsePromise || _this.hasUnmounted) {
                    // tslint:disable-next-line:no-console
                    console.warn("Discarding outdated response promise", responsePromise);
                    return;
                }
                if (triggerGetResult) {
                    _this.setState({ response: response, responsePromise: null });
                    _this.getResult(response, resultPaging);
                }
                else {
                    _this.setState({ response: response, isLoading: false, responsePromise: null });
                }
            }, function (error) {
                if (responsePromise !== _this.state.responsePromise || _this.hasUnmounted) {
                    // tslint:disable-next-line:no-console
                    console.warn("Discarding outdated response promise", responsePromise);
                    return;
                }
                _this.setState({ error: errorHandlers_1.convertErrors(error), isLoading: false, responsePromise: null });
            });
        };
        _this.getResult = function (response, paging) {
            var resultPromise = _this.sdk.execution.getPartialExecutionResult(response.links.executionResult, paging.limit, paging.offset);
            _this.setState({ isLoading: true, result: null, error: null, resultPromise: resultPromise });
            resultPromise.then(function (result) {
                if (resultPromise !== _this.state.resultPromise || _this.hasUnmounted) {
                    // tslint:disable-next-line:no-console
                    console.warn("Discarding outdated result promise", resultPromise);
                    return;
                }
                _this.setState({ result: result, isLoading: false, resultPromise: null });
            }, function (error) {
                if (resultPromise !== _this.state.resultPromise || _this.hasUnmounted) {
                    // tslint:disable-next-line:no-console
                    console.warn("Discarding outdated result promise", resultPromise);
                    return;
                }
                _this.setState({ isLoading: false, error: errorHandlers_1.convertErrors(error), resultPromise: null });
            });
        };
        _this.getInitialPaging = function () {
            var _a = _this.props, initialPaging = _a.initialPaging, dimensions = _a.dimensions;
            if (initialPaging) {
                return initialPaging;
            }
            var defaultDimensionOffset = 0;
            var defaultDimensionItemLimit = 100;
            var paging = {
                offset: dimensions.map(function () { return defaultDimensionOffset; }),
                limit: dimensions.map(function () { return defaultDimensionItemLimit; }),
            };
            return paging;
        };
        _this.state = {
            result: null,
            response: null,
            isLoading: props.autoLoadFirstPage,
            error: null,
            responsePromise: null,
            resultPromise: null,
            children: props.children,
            projectId: props.projectId,
            dimensions: props.dimensions,
            filters: props.filters,
            sortBy: props.sortBy,
        };
        _this.sdk = setupSdk(props);
        _this.hasUnmounted = false;
        return _this;
    }
    BucketExecutor.getDerivedStateFromProps = function (nextProps, prevState) {
        var newState = {};
        var arePropsInSync = true;
        propsRequiringStateUpdate.forEach(function (propName) {
            if (nextProps[propName] !== prevState[propName]) {
                arePropsInSync = false;
                newState[propName] = nextProps[propName];
            }
        });
        if (arePropsInSync) {
            return null;
        }
        newState.isLoading = nextProps.autoLoadFirstPage;
        newState.response = null;
        newState.responsePromise = null;
        newState.result = null;
        newState.resultPromise = null;
        return newState;
    };
    BucketExecutor.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (this.props.sdk !== prevProps.sdk) {
            // tslint:disable-next-line:no-console
            console.warn("Do not change the sdk prop once set. If you need to do this, force remount using the key attribute.");
        }
        if (didPropsChange(propsRequiringDataReset, prevState, this.state) && this.props.autoLoadFirstPage) {
            this.getResponse();
        }
    };
    BucketExecutor.prototype.componentDidMount = function () {
        if (this.props.autoLoadFirstPage) {
            this.getResponse();
        }
    };
    BucketExecutor.prototype.componentWillUnmount = function () {
        this.hasUnmounted = true;
    };
    BucketExecutor.prototype.render = function () {
        var _a = this.state, isLoading = _a.isLoading, result = _a.result, response = _a.response, error = _a.error, children = _a.children;
        var _b = this.props, LoadingComponent = _b.LoadingComponent, ErrorComponent = _b.ErrorComponent;
        var childrenProps = {
            result: result,
            response: response,
            getPage: this.getPage,
        };
        if (error) {
            return React.createElement(ErrorComponent, { code: error.code, message: error.message, getPage: this.getPage });
        }
        if (isLoading) {
            return React.createElement(LoadingComponent, null);
        }
        return children(childrenProps);
    };
    BucketExecutor.defaultProps = {
        sdk: gooddata_js_1.factory(),
        filters: [],
        sortBy: [],
        autoLoadFirstPage: true,
        telemetryComponentName: "BucketExecutor",
        LoadingComponent: LoadingComponent_1.LoadingComponent,
        ErrorComponent: ErrorComponent_1.ErrorComponent,
    };
    return BucketExecutor;
}(React.Component));
exports.BucketExecutor = BucketExecutor;
//# sourceMappingURL=BucketExecutor.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errorStates_1 = require("../constants/errorStates");
var get = require("lodash/get");
var includes = require("lodash/includes");
var HttpStatusCodes = require("http-status-codes");
var RuntimeError_1 = require("../errors/RuntimeError");
var utils_1 = require("./utils");
function getJSONFromText(data) {
    try {
        return JSON.parse(data);
    }
    catch (e) {
        return null;
    }
}
function isApiResponseError(error) {
    return error && error.response !== undefined;
}
exports.isApiResponseError = isApiResponseError;
function generateErrorMap(intl) {
    var _a;
    var errorMap = (_a = {},
        _a[errorStates_1.ErrorStates.DATA_TOO_LARGE_TO_DISPLAY] = {
            icon: "icon-cloud-rain",
            message: intl.formatMessage({ id: "visualization.ErrorMessageDataTooLarge" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionDataTooLarge" }),
        },
        _a[errorStates_1.ErrorStates.NOT_FOUND] = {
            message: intl.formatMessage({ id: "visualization.ErrorMessageNotFound" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionNotFound" }),
        },
        _a[errorStates_1.ErrorStates.UNAUTHORIZED] = {
            message: intl.formatMessage({ id: "visualization.ErrorMessageUnauthorized" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionUnauthorized" }),
        },
        _a[errorStates_1.ErrorStates.NO_DATA] = {
            icon: "icon-filter",
            message: intl.formatMessage({ id: "visualization.ErrorMessageNoData" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionNoData" }),
        },
        _a[errorStates_1.ErrorStates.UNKNOWN_ERROR] = {
            message: intl.formatMessage({ id: "visualization.ErrorMessageGeneric" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionGeneric" }),
        },
        _a[errorStates_1.ErrorStates.GEO_MAPBOX_TOKEN_MISSING] = {
            message: intl.formatMessage({ id: "visualization.ErrorMessageGeneric" }),
            description: intl.formatMessage({ id: "visualization.ErrorDescriptionMissingMapboxToken" }),
        },
        _a);
    return errorMap;
}
exports.generateErrorMap = generateErrorMap;
// CAREFUL: error can also be of different type than listed
function convertErrors(error) {
    if (!isApiResponseError(error)) {
        return new RuntimeError_1.RuntimeError(error.message, error);
    }
    var errorCode = error.response.status;
    switch (errorCode) {
        case HttpStatusCodes.NO_CONTENT:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.NO_DATA, error);
        case HttpStatusCodes.REQUEST_TOO_LONG:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.DATA_TOO_LARGE_TO_COMPUTE, error);
        case HttpStatusCodes.BAD_REQUEST:
            var message = get(getJSONFromText(error.responseBody), "error.message", "");
            if (includes(message, "Attempt to execute protected report unsafely")) {
                return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.PROTECTED_REPORT, error);
            }
            else {
                return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.BAD_REQUEST, error);
            }
        case HttpStatusCodes.NOT_FOUND:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.NOT_FOUND, error);
        case HttpStatusCodes.UNAUTHORIZED:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.UNAUTHORIZED, error);
        case errorStates_1.ErrorCodes.EMPTY_AFM:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.EMPTY_AFM);
        case errorStates_1.ErrorCodes.INVALID_BUCKETS:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.INVALID_BUCKETS);
        default:
            return new RuntimeError_1.RuntimeError(errorStates_1.ErrorStates.UNKNOWN_ERROR);
    }
}
exports.convertErrors = convertErrors;
/** @deprecated */
function isNullExecutionResult(responses) {
    return responses.executionResult === null;
}
function hasEmptyData(responses) {
    return responses.executionResult.data.length === 0;
}
function hasMissingHeaderItems(responses) {
    return !responses.executionResult.headerItems;
}
function isEmptyDataResult(responses) {
    return hasEmptyData(responses) && hasMissingHeaderItems(responses);
}
/**
 * isEmptyResult
 * is a function that returns true if the execution result is empty (no data points) and false otherwise.
 * @param responses:Execution.IExecutionResponses - object with execution response and result
 * @return boolean
 * @internal
 */
function isEmptyResult(responses) {
    return isNullExecutionResult(responses) || isEmptyDataResult(responses);
}
exports.isEmptyResult = isEmptyResult;
function checkEmptyResult(responses) {
    if (isEmptyResult(responses)) {
        throw {
            name: "EmptyResultError",
            response: {
                status: HttpStatusCodes.NO_CONTENT,
                json: function () { return Promise.resolve(responses); },
                text: function () { return Promise.resolve(null); },
            },
        };
    }
    return responses;
}
exports.checkEmptyResult = checkEmptyResult;
exports.hasDuplicateIdentifiers = function (buckets) {
    var buffer = [];
    var duplicates = [];
    buckets.forEach(function (_a) {
        var items = _a.items;
        items.forEach(function (bucketItem) {
            var localIdentifier = utils_1.unwrap(bucketItem).localIdentifier;
            var isDuplicate = buffer.includes(localIdentifier);
            buffer.push(localIdentifier);
            if (isDuplicate && !duplicates.includes(localIdentifier)) {
                duplicates.push(localIdentifier);
            }
        });
    });
    if (duplicates.length > 0) {
        // tslint:disable-next-line:no-console max-line-length
        console.warn("Duplicate identifier" + (duplicates.length > 1 ? "s" : "") + " '" + duplicates.join(", ") + "' detected in PivotTable. Please make sure all localIdentifiers are unique.");
    }
    return duplicates.length > 0;
};
//# sourceMappingURL=errorHandlers.js.map
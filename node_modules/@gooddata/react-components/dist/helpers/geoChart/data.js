"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2020 GoodData Corporation
var get = require("lodash/get");
var typings_1 = require("@gooddata/typings");
var bucketNames_1 = require("../../constants/bucketNames");
var executionResultHelper_1 = require("../executionResultHelper");
var utils_1 = require("../utils");
var common_1 = require("./common");
var mdObjectHelper_1 = require("../../internal/utils/mdObjectHelper");
function getLocation(latlng) {
    if (!latlng) {
        return null;
    }
    var _a = latlng.split(";").map(utils_1.stringToFloat), latitude = _a[0], longitude = _a[1];
    if (isNaN(latitude) || isNaN(longitude)) {
        // tslint:disable-next-line:no-console
        console.warn("UI-SDK: geoChartDataSource - getLocation: invalid location", latlng);
        return null;
    }
    return {
        lat: latitude,
        lng: longitude,
    };
}
exports.getLocation = getLocation;
function getGeoData(buckets, execution) {
    var executionResponse = execution.executionResponse, executionResult = execution.executionResult;
    var geoData = getBucketItemNameAndDataIndex(buckets, executionResponse.dimensions);
    var attributeHeaderItems = common_1.getGeoAttributeHeaderItems(executionResult, geoData);
    var locationIndex = get(geoData, bucketNames_1.LOCATION + ".index");
    var segmentIndex = get(geoData, bucketNames_1.SEGMENT + ".index");
    var tooltipTextIndex = get(geoData, bucketNames_1.TOOLTIP_TEXT + ".index");
    var sizeIndex = get(geoData, bucketNames_1.SIZE + ".index");
    var colorIndex = get(geoData, bucketNames_1.COLOR + ".index");
    if (locationIndex !== undefined) {
        var locationData = getAttributeData(attributeHeaderItems, locationIndex);
        geoData[bucketNames_1.LOCATION].data = locationData.map(getLocation);
    }
    if (segmentIndex !== undefined) {
        var _a = getSegmentDataAndUris(attributeHeaderItems, segmentIndex), data = _a.data, uris = _a.uris;
        geoData[bucketNames_1.SEGMENT].data = data;
        geoData[bucketNames_1.SEGMENT].uris = uris;
    }
    if (tooltipTextIndex !== undefined) {
        geoData[bucketNames_1.TOOLTIP_TEXT].data = getAttributeData(attributeHeaderItems, tooltipTextIndex);
    }
    if (sizeIndex !== undefined) {
        geoData[bucketNames_1.SIZE].data = getMeasureData(executionResult, sizeIndex);
        geoData[bucketNames_1.SIZE].format = common_1.getFormatFromExecutionResponse(executionResponse, sizeIndex);
    }
    if (colorIndex !== undefined) {
        geoData[bucketNames_1.COLOR].data = getMeasureData(executionResult, colorIndex);
        geoData[bucketNames_1.COLOR].format = common_1.getFormatFromExecutionResponse(executionResponse, colorIndex);
    }
    return geoData;
}
exports.getGeoData = getGeoData;
function getMeasureData(executionResult, dataIndex) {
    var data = executionResult.data;
    if (!executionResultHelper_1.isTwoDimensionsData(data)) {
        return [];
    }
    var measureValues = data[dataIndex];
    return measureValues.map(utils_1.stringToFloat);
}
function getAttributeData(attributeHeaderItems, dataIndex) {
    var headerItems = attributeHeaderItems[dataIndex];
    return headerItems.map(executionResultHelper_1.getHeaderItemName);
}
function getSegmentDataAndUris(attributeHeaderItems, dataIndex) {
    var headerItems = attributeHeaderItems[dataIndex];
    return headerItems.reduce(function (result, headerItem) {
        if (headerItem && typings_1.Execution.isAttributeHeaderItem(headerItem)) {
            var _a = headerItem.attributeHeaderItem, uri = _a.uri, name_1 = _a.name;
            return { uris: result.uris.concat([uri]), data: result.data.concat([name_1]) };
        }
        return result;
    }, { uris: [], data: [] });
}
function getBucketItemNameAndDataIndex(buckets, dimensions) {
    var measureGroupHeader = executionResultHelper_1.getMeasureGroupHeaderItemsInDimension(dimensions);
    var attributeHeaders = executionResultHelper_1.getAttributeHeadersInDimension(dimensions);
    var bucketItemInfos = buckets.reduce(function (result, bucket) {
        var _a;
        return (__assign({}, result, (_a = {}, _a[bucket.localIdentifier] = getBucketItemInfo(bucket.items[0]), _a)));
    }, {});
    // init data
    var result = {};
    [bucketNames_1.LOCATION, bucketNames_1.SEGMENT, bucketNames_1.TOOLTIP_TEXT].forEach(function (bucketName) {
        var bucketItemInfo = bucketItemInfos[bucketName];
        if (!bucketItemInfo) {
            return;
        }
        var index = attributeHeaders.findIndex(function (attributeHeader) {
            return attributeHeader.localIdentifier === bucketItemInfo.localIdentifier &&
                (attributeHeader.uri === bucketItemInfo.uri ||
                    attributeHeader.identifier === bucketItemInfo.identifier);
        });
        if (index !== -1) {
            var name_2 = attributeHeaders[index].formOf.name;
            result[bucketName] = { index: index, name: name_2 };
        }
    });
    [bucketNames_1.SIZE, bucketNames_1.COLOR].forEach(function (bucketName) {
        var bucketItemInfo = bucketItemInfos[bucketName];
        if (!bucketItemInfo) {
            return;
        }
        var index = measureGroupHeader.findIndex(function (measureHeaderItem) {
            return measureHeaderItem.measureHeaderItem.localIdentifier === bucketItemInfo.localIdentifier &&
                (measureHeaderItem.measureHeaderItem.uri === bucketItemInfo.uri ||
                    measureHeaderItem.measureHeaderItem.identifier === bucketItemInfo.identifier);
        });
        if (index !== -1) {
            result[bucketName] = {
                index: index,
                name: measureGroupHeader[index].measureHeaderItem.name,
            };
        }
    });
    return result;
}
function getUriAndIdentifier(objQualifier) {
    if (mdObjectHelper_1.isDisplayFormUri(objQualifier)) {
        return {
            uri: objQualifier.uri,
        };
    }
    return {
        identifier: objQualifier.identifier,
    };
}
function getBucketItemInfo(bucketItem) {
    if (!bucketItem) {
        return null;
    }
    // attribute item
    if (typings_1.VisualizationObject.isVisualizationAttribute(bucketItem)) {
        var _a = bucketItem.visualizationAttribute, displayForm = _a.displayForm, localIdentifier_1 = _a.localIdentifier;
        return __assign({ localIdentifier: localIdentifier_1 }, getUriAndIdentifier(displayForm));
    }
    // measure item
    var _b = bucketItem.measure, definition = _b.definition, localIdentifier = _b.localIdentifier;
    var item = typings_1.VisualizationObject.isMeasureDefinition(definition) && definition.measureDefinition.item;
    return __assign({ localIdentifier: localIdentifier }, getUriAndIdentifier(item));
}
function buildTooltipBucketItem(tooltipText) {
    return {
        localIdentifier: bucketNames_1.TOOLTIP_TEXT,
        items: [
            {
                visualizationAttribute: {
                    localIdentifier: bucketNames_1.TOOLTIP_TEXT,
                    displayForm: {
                        uri: tooltipText,
                    },
                },
            },
        ],
    };
}
exports.getGeoBucketsFromMdObject = function (mdObject) {
    if (!mdObject) {
        return [];
    }
    var _a = mdObject.buckets, buckets = _a === void 0 ? [] : _a, properties = mdObject.properties;
    var propertiesObj = parseGeoPropertyItem(properties);
    var tooltipText = get(propertiesObj, "controls.tooltipText");
    if (tooltipText) {
        return buckets.concat([buildTooltipBucketItem(tooltipText)]);
    }
    return buckets;
};
function getAvailableLegends(categoryItems, geoData) {
    var _a = geoData.color, _b = (_a === void 0 ? {} : _a).data, colorData = _b === void 0 ? [] : _b, _c = geoData.size, _d = (_c === void 0 ? {} : _c).data, sizeData = _d === void 0 ? [] : _d;
    var _e = utils_1.getMinMax(colorData), minColor = _e.min, maxColor = _e.max;
    var _f = utils_1.getMinMax(sizeData), minSize = _f.min, maxSize = _f.max;
    var hasCategoryLegend = Boolean(categoryItems && categoryItems.length);
    var hasColorLegend = Boolean(colorData.length) && minColor !== maxColor && !hasCategoryLegend;
    var hasSizeLegend = Boolean(sizeData.length) && minSize !== maxSize;
    return {
        hasCategoryLegend: hasCategoryLegend,
        hasColorLegend: hasColorLegend,
        hasSizeLegend: hasSizeLegend,
    };
}
exports.getAvailableLegends = getAvailableLegends;
function parseGeoPropertyItem(item) {
    try {
        return JSON.parse(item);
    }
    catch (e) {
        return {};
    }
}
function parseGeoProperties(properties) {
    var _a = properties.locationName, locationName = _a === void 0 ? "{}" : _a, _b = properties.color, color = _b === void 0 ? "{}" : _b, _c = properties.size, size = _c === void 0 ? "{}" : _c, _d = properties.segment, segment = _d === void 0 ? "{}" : _d;
    return {
        locationName: parseGeoPropertyItem(locationName),
        size: parseGeoPropertyItem(size),
        color: parseGeoPropertyItem(color),
        segment: parseGeoPropertyItem(segment),
    };
}
exports.parseGeoProperties = parseGeoProperties;
//# sourceMappingURL=data.js.map
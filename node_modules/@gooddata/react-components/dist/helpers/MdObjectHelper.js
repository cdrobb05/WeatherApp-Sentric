"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var get = require("lodash/get");
var typings_1 = require("@gooddata/typings");
var gooddata_js_1 = require("@gooddata/gooddata-js");
var bucketNames_1 = require("../constants/bucketNames");
var afmHelper_1 = require("./afmHelper");
var mdObjBucketHelper_1 = require("./mdObjBucketHelper");
var attributes_1 = require("../helpers/model/attributes");
var common_1 = require("./geoChart/common");
function getTotals(mdObject) {
    var attributes = mdObject.content.buckets.find(function (bucket) { return bucket.localIdentifier === bucketNames_1.ATTRIBUTE; });
    return get(attributes, "totals", []);
}
function getVisualizationClassUri(mdObject) {
    return get(mdObject, "content.visualizationClass.uri", "");
}
/**
 * Build properties object used by the {ArithmeticMeasureTitleFactory} to not be dependent on the
 * {VisualizationObject.IMeasure}. It contains all the necessary properties related to the measure title.
 * @param measures - The measures that will be converted.
 * @return The array of {IMeasureTitleProps} objects.
 *
 * @internal
 */
function buildMeasureTitleProps(measures) {
    return measures.map(function (measure) { return ({
        localIdentifier: measure.measure.localIdentifier,
        title: measure.measure.title,
        alias: measure.measure.alias,
    }); });
}
/**
 * Build properties object used by the {ArithmeticMeasureTitleFactory} to not be dependent on the
 * {VisualizationObject.IArithmeticMeasureDefinition}. It contains all the necessary properties from the arithmetic
 * measure.
 * @param measureDefinition - The definition of the arithmetic measure that will be converted.
 * @return {IArithmeticMeasureTitleProps}
 *
 * @internal
 */
function buildArithmeticMeasureTitleProps(measureDefinition) {
    var _a = measureDefinition.arithmeticMeasure, operator = _a.operator, measureIdentifiers = _a.measureIdentifiers;
    return {
        operator: operator,
        masterMeasureLocalIdentifiers: measureIdentifiers,
    };
}
exports.mdObjectToGeoPushpinBucketProps = function (config, mdObject, filtersFromProps) {
    var hasVisualizationObjectContent = mdObject && mdObject.content;
    if (!hasVisualizationObjectContent) {
        return {};
    }
    var content = mdObject.content;
    var contentBuckets = content.buckets;
    var colorBucket = mdObjBucketHelper_1.findBucketByLocalIdentifier(contentBuckets, bucketNames_1.COLOR);
    var locationBucket = mdObjBucketHelper_1.findBucketByLocalIdentifier(contentBuckets, bucketNames_1.LOCATION);
    var segmentByBucket = mdObjBucketHelper_1.findBucketByLocalIdentifier(contentBuckets, bucketNames_1.SEGMENT);
    var sizeBucket = mdObjBucketHelper_1.findBucketByLocalIdentifier(contentBuckets, bucketNames_1.SIZE);
    var color = colorBucket && colorBucket.items[0];
    var location = locationBucket && locationBucket.items[0];
    var segmentBy = segmentByBucket && segmentByBucket.items[0];
    var size = sizeBucket && sizeBucket.items[0];
    var sortBy = [];
    var afmWithoutMergedFilters = gooddata_js_1.DataLayer.toAfmResultSpec(content).afm;
    afmWithoutMergedFilters.filters = afmWithoutMergedFilters.filters || [];
    var afm = afmHelper_1.mergeFiltersToAfm(afmWithoutMergedFilters, filtersFromProps);
    // Filter out expression filters which are not supported in bucket interface
    var filters = (afm.filters || []).filter(function (afmFilter) { return !typings_1.AFM.isExpressionFilter(afmFilter); });
    var tooltipTextDisplayForm = config.tooltipText;
    var configWithTooltipText = __assign({}, config);
    if (tooltipTextDisplayForm && common_1.isTooltipTextValueString(tooltipTextDisplayForm)) {
        // tooltipText uri was built from properties.control
        configWithTooltipText.tooltipText = attributes_1.attribute(tooltipTextDisplayForm).localIdentifier(bucketNames_1.TOOLTIP_TEXT);
    }
    return {
        color: color,
        config: configWithTooltipText,
        location: location,
        segmentBy: segmentBy,
        size: size,
        filters: filters,
        sortBy: sortBy,
    };
};
exports.mdObjectToPivotBucketProps = function (mdObject, filtersFromProps) {
    var measureBucket = mdObject.content.buckets.find(function (bucket) { return bucket.localIdentifier === bucketNames_1.MEASURES; });
    var rowBucket = mdObject.content.buckets.find(function (bucket) { return bucket.localIdentifier === bucketNames_1.ATTRIBUTE; });
    var columnBucket = mdObject.content.buckets.find(function (bucket) { return bucket.localIdentifier === bucketNames_1.COLUMNS; });
    var measures = (measureBucket && measureBucket.items) || [];
    var rows = (rowBucket && rowBucket.items) || [];
    var columns = (columnBucket && columnBucket.items) || [];
    var sortBy = (mdObject &&
        mdObject.content &&
        mdObject.content.properties &&
        JSON.parse(mdObject.content.properties).sortItems) ||
        [];
    var totals = (rowBucket && rowBucket.totals) || [];
    var afmWithoutMergedFilters = gooddata_js_1.DataLayer.toAfmResultSpec(mdObject.content).afm;
    afmWithoutMergedFilters.filters = afmWithoutMergedFilters.filters || [];
    var afm = afmHelper_1.mergeFiltersToAfm(afmWithoutMergedFilters, filtersFromProps);
    // Filter out expression filters which are not supported in bucket interface
    var filters = (afm.filters || []).filter(function (afmFilter) { return !typings_1.AFM.isExpressionFilter(afmFilter); });
    return {
        measures: measures,
        rows: rows,
        columns: columns,
        filters: filters,
        sortBy: sortBy,
        totals: totals,
    };
};
function getMeasuresFromMdObject(mdObject) {
    return get(mdObject, "buckets").reduce(function (acc, bucket) {
        var measureItems = get(bucket, "items", []).filter(typings_1.VisualizationObject.isMeasure);
        return acc.concat(measureItems);
    }, []);
}
exports.getMeasuresFromMdObject = getMeasuresFromMdObject;
function areAllMeasuresOnSingleAxis(mdObject, secondaryYAxis) {
    var measureCount = getMeasuresFromMdObject(mdObject).length;
    var numberOfMeasureOnSecondaryAxis = get(secondaryYAxis, "measures.length", 0);
    return numberOfMeasureOnSecondaryAxis === 0 || measureCount === numberOfMeasureOnSecondaryAxis;
}
exports.areAllMeasuresOnSingleAxis = areAllMeasuresOnSingleAxis;
exports.default = {
    getTotals: getTotals,
    getVisualizationClassUri: getVisualizationClassUri,
    buildMeasureTitleProps: buildMeasureTitleProps,
    buildArithmeticMeasureTitleProps: buildArithmeticMeasureTitleProps,
    mdObjectToGeoPushpinBucketProps: exports.mdObjectToGeoPushpinBucketProps,
    mdObjectToPivotBucketProps: exports.mdObjectToPivotBucketProps,
};
//# sourceMappingURL=MdObjectHelper.js.map
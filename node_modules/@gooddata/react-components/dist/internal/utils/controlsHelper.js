"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2019 GoodData Corporation
var get = require("lodash/get");
var set = require("lodash/set");
var translations_1 = require("./translations");
function fixEmptyMaxValue(value) {
    return value === "" ? Number.MAX_SAFE_INTEGER : Number(value);
}
exports.fixEmptyMaxValue = fixEmptyMaxValue;
function fixEmptyMinValue(value) {
    return value === "" ? Number.MIN_SAFE_INTEGER : Number(value);
}
exports.fixEmptyMinValue = fixEmptyMinValue;
function isValueMinusOrEmpty(value) {
    return value === "-" || value === "";
}
exports.isValueMinusOrEmpty = isValueMinusOrEmpty;
function isInvalidOrMinMaxError(value, minNumberValue, maxNumberValue) {
    var valueIsMinus = value === "-";
    var maxMinNumbers = !isNaN(minNumberValue) && !isNaN(maxNumberValue);
    return valueIsMinus || !maxMinNumbers || minNumberValue > maxNumberValue;
}
exports.isInvalidOrMinMaxError = isInvalidOrMinMaxError;
function maxInputValidateAndPushData(data, state, props, setState, defaultState) {
    var basePath = props.basePath;
    var maxValue = get(data, "properties.controls." + basePath + ".max");
    var incorrectMinValue = get(state, "minScale.incorrectValue", "");
    var correctMinValue = get(props, "properties.controls." + basePath + ".min", "");
    var incorrectMinInvalid = isValueMinusOrEmpty(incorrectMinValue);
    var minNumberValue = incorrectMinInvalid
        ? fixEmptyMinValue(correctMinValue)
        : Number(incorrectMinValue);
    var maxNumberValue = fixEmptyMaxValue(maxValue);
    var maxIsMinus = maxValue === "-";
    var propertiesMeta = props.propertiesMeta, pushData = props.pushData;
    set(propertiesMeta, "undoApplied", false);
    // dash, non-numeric or min/max mismatch: set error
    if (isInvalidOrMinMaxError(maxValue, minNumberValue, maxNumberValue)) {
        setState({
            minScale: __assign({}, state.minScale, { hasWarning: incorrectMinValue === "-" }),
            maxScale: {
                hasWarning: true,
                // no error message for dash
                warningMessage: maxIsMinus ? "" : translations_1.getTranslation("properties.axis.max.warning", props.intl),
                incorrectValue: maxValue,
            },
        });
        pushData({ propertiesMeta: propertiesMeta }); // post undoApplied flag to AD
        return;
    }
    // valid, set new value
    var properties = props.properties;
    set(properties, "controls." + basePath + ".max", maxValue);
    // if incorrect value was set previously but now validation passed, set incorrect value as correct value
    if (isNaN(parseFloat(incorrectMinValue))) {
        setState({
            maxScale: defaultState.maxScale,
        });
    }
    else {
        set(properties, "controls." + basePath + ".min", incorrectMinValue);
        setState(defaultState);
    }
    pushData({ properties: properties, propertiesMeta: propertiesMeta });
}
exports.maxInputValidateAndPushData = maxInputValidateAndPushData;
function minInputValidateAndPushData(data, state, props, setState, defaultState) {
    var basePath = props.basePath;
    var minValue = get(data, "properties.controls." + basePath + ".min");
    var incorrectMaxValue = get(state, "maxScale.incorrectValue", "");
    var correctMaxValue = get(props, "properties.controls." + basePath + ".max", "");
    var incorrectMaxInvalid = isValueMinusOrEmpty(incorrectMaxValue);
    var maxNumberValue = incorrectMaxInvalid
        ? fixEmptyMaxValue(correctMaxValue)
        : Number(incorrectMaxValue);
    var minNumberValue = fixEmptyMinValue(minValue);
    var minIsDash = minValue === "-";
    var propertiesMeta = props.propertiesMeta, pushData = props.pushData;
    set(propertiesMeta, "undoApplied", false);
    // dash, non-numeric or min/max mismatch: set error
    if (isInvalidOrMinMaxError(minValue, minNumberValue, maxNumberValue)) {
        setState({
            maxScale: __assign({}, state.maxScale, { hasWarning: incorrectMaxValue === "-" }),
            minScale: {
                hasWarning: true,
                // no error message for dash
                warningMessage: minIsDash ? "" : translations_1.getTranslation("properties.axis.min.warning", props.intl),
                incorrectValue: minValue,
            },
        });
        pushData({ propertiesMeta: propertiesMeta }); // post undoApplied flag to AD
        return;
    }
    // valid, set new value
    var properties = props.properties;
    set(properties, "controls." + basePath + ".min", minValue);
    // if incorrect value was set previously but now validation passed, set incorrect value as correct value
    if (isNaN(parseFloat(incorrectMaxValue))) {
        setState({
            minScale: defaultState.minScale,
        });
    }
    else {
        set(properties, "controls." + basePath + ".max", incorrectMaxValue);
        setState(defaultState);
    }
    pushData({ properties: properties, propertiesMeta: propertiesMeta });
}
exports.minInputValidateAndPushData = minInputValidateAndPushData;
//# sourceMappingURL=controlsHelper.js.map
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2019-2020 GoodData Corporation
var get = require("lodash/get");
var set = require("lodash/set");
var includes = require("lodash/includes");
var every = require("lodash/every");
var isEmpty = require("lodash/isEmpty");
var omitBy = require("lodash/omitBy");
var isNil = require("lodash/isNil");
var typings_1 = require("@gooddata/typings");
var gooddata_js_1 = require("@gooddata/gooddata-js");
var sort_1 = require("../constants/sort");
var bucketHelper_1 = require("./bucketHelper");
var visualizationTypes_1 = require("../../constants/visualizationTypes");
var SortsHelper = require("../../helpers/sorts");
function getMeasureSortItems(identifier, direction) {
    return [
        {
            measureSortItem: {
                direction: direction,
                locators: [
                    {
                        measureLocatorItem: {
                            measureIdentifier: identifier,
                        },
                    },
                ],
            },
        },
    ];
}
exports.getMeasureSortItems = getMeasureSortItems;
function getDefaultTableSort(afm) {
    var attribute = get(afm, "attributes.0");
    if (!attribute) {
        return SortsHelper.getFirstMeasureSort(afm);
    }
    return [SortsHelper.getAttributeSortItem(attribute.localIdentifier, sort_1.SORT_DIR_ASC)];
}
function getDefaultGeoPushpinSort(afm) {
    return SortsHelper.getDefaultAttributeGeoPushpinSort(afm);
}
function getDefaultPivotTableSort(afm) {
    var attribute = get(afm, "attributes.0");
    if (!attribute) {
        return [];
    }
    return [];
}
exports.getDefaultPivotTableSort = getDefaultPivotTableSort;
function sanitizeSorts(afm, sorts) {
    if (isEmpty(sorts)) {
        return [];
    }
    return sorts.filter(function (sortItem) { return gooddata_js_1.DataLayer.ResultSpecUtils.isSortValid(afm, sortItem); });
}
// Consider disolving this function into individual components
function createSorts(type, afm, resultSpec, visualizationProperties, canSortStackTotalValue, enableSortingByTotalGroup) {
    if (canSortStackTotalValue === void 0) { canSortStackTotalValue = false; }
    if (enableSortingByTotalGroup === void 0) { enableSortingByTotalGroup = false; }
    var sortItems = get(visualizationProperties, "sortItems", []);
    var sanitizedSortItems = sanitizeSorts(afm, sortItems);
    // reuse sorts only for Table
    // This does not apply to PivotTable, it doesn't use this function at all
    if (type === visualizationTypes_1.VisualizationTypes.TABLE && !isEmpty(sanitizedSortItems)) {
        return sanitizedSortItems;
    }
    switch (type) {
        case visualizationTypes_1.VisualizationTypes.TABLE:
            return getDefaultTableSort(afm);
        case visualizationTypes_1.VisualizationTypes.COLUMN:
        case visualizationTypes_1.VisualizationTypes.LINE:
            return [];
        case visualizationTypes_1.VisualizationTypes.BAR:
            return SortsHelper.getDefaultBarChartSort(afm, resultSpec, canSortStackTotalValue, enableSortingByTotalGroup);
        case visualizationTypes_1.VisualizationTypes.TREEMAP:
            return SortsHelper.getDefaultTreemapSort(afm, resultSpec);
        case visualizationTypes_1.VisualizationTypes.PUSHPIN:
            return getDefaultGeoPushpinSort(afm);
        case visualizationTypes_1.VisualizationTypes.HEATMAP:
            return SortsHelper.getDefaultHeatmapSort(resultSpec);
    }
    return [];
}
exports.createSorts = createSorts;
function getBucketItemIdentifiers(referencePoint) {
    var buckets = get(referencePoint, "buckets", []);
    return buckets.reduce(function (localIdentifiers, bucket) {
        var items = get(bucket, "items", []);
        return localIdentifiers.concat(items.map(function (item) { return item.localIdentifier; }));
    }, []);
}
exports.getBucketItemIdentifiers = getBucketItemIdentifiers;
function getSortIdentifiers(item) {
    if (typings_1.AFM.isMeasureSortItem(item)) {
        return get(item, "measureSortItem.locators", []).map(function (locator) {
            if (get(locator, "measureLocatorItem")) {
                return get(locator, "measureLocatorItem.measureIdentifier");
            }
            else {
                return get(locator, "attributeLocatorItem.attributeIdentifier");
            }
        });
    }
    if (typings_1.AFM.isAttributeSortItem(item)) {
        var attribute = get(item, "attributeSortItem.attributeIdentifier");
        if (attribute) {
            return [attribute];
        }
    }
    return [];
}
exports.getSortIdentifiers = getSortIdentifiers;
function isSortItemValid(item, identifiers) {
    var sortIdentifiers = getSortIdentifiers(item);
    return every(sortIdentifiers, function (id) { return includes(identifiers, id); });
}
function removeSort(referencePoint) {
    if (referencePoint.properties) {
        var properties = omitBy(__assign({}, referencePoint.properties, { sortItems: null }), isNil);
        return __assign({}, referencePoint, { properties: properties });
    }
    return referencePoint;
}
exports.removeSort = removeSort;
function removeInvalidSort(referencePoint) {
    if (referencePoint.properties) {
        var identifiers_1 = getBucketItemIdentifiers(referencePoint);
        var sortItems = referencePoint.properties.sortItems || [];
        sortItems = sortItems.filter(function (item) {
            return isSortItemValid(item, identifiers_1);
        });
        return __assign({}, referencePoint, { properties: __assign({}, referencePoint.properties, { sortItems: sortItems }) });
    }
    return referencePoint;
}
exports.removeInvalidSort = removeInvalidSort;
function setSortItems(referencePoint) {
    var buckets = referencePoint.buckets;
    var sortItems = get(referencePoint, ["properties", "sortItems"], []);
    if (sortItems.length > 0) {
        return referencePoint;
    }
    var firstMeasure = bucketHelper_1.getFirstValidMeasure(buckets);
    var firstAttribute = bucketHelper_1.getFirstAttribute(buckets);
    if (firstMeasure !== null && firstAttribute == null) {
        set(referencePoint, ["properties", "sortItems"], getMeasureSortItems(firstMeasure.localIdentifier, sort_1.SORT_DIR_DESC));
    }
    else if (firstAttribute !== null) {
        set(referencePoint, ["properties", "sortItems"], [SortsHelper.getAttributeSortItem(firstAttribute.localIdentifier, sort_1.SORT_DIR_ASC)]);
    }
    return referencePoint;
}
exports.setSortItems = setSortItems;
//# sourceMappingURL=sort.js.map
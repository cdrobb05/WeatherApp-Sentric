"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IntlStore_1 = require("../helpers/IntlStore");
/**
 * Factory that builds formatted localized titles of arithmetic measures.
 * The title is used during AFM execution and for bucket item titles.
 *
 * @internal
 */
var ArithmeticMeasureTitleFactory = /** @class */ (function () {
    /**
     * Create a new instance of the class.
     * @param {Localization.ILocale} locale - The locale used for translation.
     */
    function ArithmeticMeasureTitleFactory(locale) {
        this.locale = locale;
    }
    /**
     * Returns formatted localized title string for arithmetic measure.
     *
     * @param {IArithmeticMeasureTitleProps} arithmeticMeasureProps - The properties of arithmetic measure for which
     *      the title must be obtained.
     * @param {IMeasureTitleProps} measureTitleProps - The array of objects in which the title of master measures used
     *      in arithmetic measure is looked up.
     * @returns {string} localized title of the arithmetic measure or null when arithmetic measure references invalid
     *      master measures or invalid number of master measures.
     */
    ArithmeticMeasureTitleFactory.prototype.getTitle = function (arithmeticMeasureProps, measureTitleProps) {
        var operator = arithmeticMeasureProps.operator, masterMeasureLocalIdentifiers = arithmeticMeasureProps.masterMeasureLocalIdentifiers;
        var localizationKey = this.getTitleLocalizationKey(operator);
        var masterMeasureTitles = this.getMasterMeasureTitles(masterMeasureLocalIdentifiers, measureTitleProps);
        return masterMeasureTitles === null ? null : this.translateKey(localizationKey, masterMeasureTitles);
    };
    ArithmeticMeasureTitleFactory.prototype.getTitleLocalizationKey = function (arithmeticMeasureOperator) {
        switch (arithmeticMeasureOperator) {
            case "sum":
                return "visualizations.measure.arithmetic.sum.title";
            case "difference":
                return "visualizations.measure.arithmetic.difference.title";
            case "multiplication":
                return "visualizations.measure.arithmetic.multiplication.title";
            case "ratio":
                return "visualizations.measure.arithmetic.ratio.title";
            case "change":
                return "visualizations.measure.arithmetic.change.title";
            default:
                throw Error("The arithmetic measure operator '" + arithmeticMeasureOperator + "' is not supported!");
        }
    };
    ArithmeticMeasureTitleFactory.prototype.getMasterMeasureTitles = function (masterMeasureLocalIdentifiers, measureTitles) {
        if (masterMeasureLocalIdentifiers.length < 2) {
            return null;
        }
        var firstMeasureTitle = this.findMeasureTitle(masterMeasureLocalIdentifiers[0], measureTitles);
        var secondMeasureTitle = this.findMeasureTitle(masterMeasureLocalIdentifiers[1], measureTitles);
        if (firstMeasureTitle === undefined || secondMeasureTitle === undefined) {
            return null;
        }
        return {
            firstMeasureTitle: firstMeasureTitle,
            secondMeasureTitle: secondMeasureTitle,
        };
    };
    ArithmeticMeasureTitleFactory.prototype.findMeasureTitle = function (localIdentifier, measureTitles) {
        var measureCurrentNames = measureTitles
            .filter(function (measureTitle) { return measureTitle.localIdentifier === localIdentifier; })
            .map(function (measureTitle) { return measureTitle.alias || measureTitle.title; });
        return measureCurrentNames.length > 0 ? measureCurrentNames[0] : undefined;
    };
    ArithmeticMeasureTitleFactory.prototype.translateKey = function (localizationKey, values) {
        return IntlStore_1.default.getTranslation(localizationKey, this.locale, values);
    };
    return ArithmeticMeasureTitleFactory;
}());
exports.default = ArithmeticMeasureTitleFactory;
//# sourceMappingURL=ArithmeticMeasureTitleFactory.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2019 GoodData Corporation
var capitalize = require("lodash/capitalize");
var isEqual = require("lodash/isEqual");
var typings_1 = require("@gooddata/typings");
var IntlStore_1 = require("../../../../../helpers/IntlStore");
var i18n_1 = require("../../constants/i18n");
var DateConversions_1 = require("../DateConversions");
var formatAbsoluteDate = function (date, translator) {
    return translator.formatDate(date, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
    });
};
var formatAbsoluteDateRange = function (from, to, translator) {
    var fromDate = DateConversions_1.convertPlatformDateStringToDate(from);
    var toDate = DateConversions_1.convertPlatformDateStringToDate(to);
    var fromTitle = formatAbsoluteDate(fromDate, translator);
    var toTitle = formatAbsoluteDate(toDate, translator);
    if (isEqual(fromTitle, toTitle)) {
        return fromTitle;
    }
    return fromTitle + "\u2013" + toTitle;
};
var relativeDateRangeFormatters = [
    {
        // Today, This month
        predicate: function (from, to) { return from === 0 && to === 0; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.this" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Tomorrow, Next month
        predicate: function (from, to) { return from === 1 && to === 1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.next" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Yesterday, Last month
        predicate: function (from, to) { return from === -1 && to === -1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.last" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Next N days (months)
        predicate: function (from) { return from === 0; },
        formatter: function (_from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.nextN" + capitalize(intlGranularity) + "s" }, { n: Math.abs(to) + 1 });
        },
    },
    {
        // Last N days (months)
        predicate: function (_from, to) { return to === 0; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.lastN" + capitalize(intlGranularity) + "s" }, { n: Math.abs(from) + 1 });
        },
    },
    {
        // From N days ago to M days ago
        predicate: function (from, to) { return from < 0 && to < 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.past" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ahead to M days ahead
        predicate: function (from, to) { return from > 0 && to > 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.future" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ago to M days ahead
        predicate: function () { return true; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.mixed" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
];
var formatRelativeDateRange = function (from, to, granularity, translator) {
    var intlGranularity = i18n_1.granularityIntlCodes[granularity];
    var formatter = relativeDateRangeFormatters.find(function (f) { return f.predicate(from, to); }).formatter;
    return formatter(from, to, intlGranularity, translator);
};
var getAllTimeFilterRepresentation = function (translator) {
    return translator.formatMessage({ id: "filters.allTime.title" });
};
var getAbsoluteFormFilterRepresentation = function (filter, translator) { return (filter.from && filter.to ? formatAbsoluteDateRange(filter.from, filter.to, translator) : ""); };
var getAbsolutePresetFilterRepresentation = function (filter, translator) { return formatAbsoluteDateRange(filter.from, filter.to, translator); };
var getRelativeFormFilterRepresentation = function (filter, translator) {
    return typeof filter.from === "number" && typeof filter.to === "number"
        ? formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator)
        : "";
};
var getRelativePresetFilterRepresentation = function (filter, translator) { return formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator); };
var getDateFilterRepresentationByFilterType = function (filter, translator) {
    if (typings_1.ExtendedDateFilters.isAbsoluteDateFilterForm(filter) ||
        typings_1.ExtendedDateFilters.isRelativeDateFilterForm(filter)) {
        return getDateFilterRepresentationUsingTranslator(filter, translator);
    }
    else if (typings_1.ExtendedDateFilters.isAllTimeDateFilter(filter) ||
        typings_1.ExtendedDateFilters.isAbsoluteDateFilterPreset(filter) ||
        typings_1.ExtendedDateFilters.isRelativeDateFilterPreset(filter)) {
        return filter.name || getDateFilterRepresentationUsingTranslator(filter, translator);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
// excludeCurrentPeriod is extra metadata that is needed by translation, but it is only used by relative filters
// so the data structure is little inconsistent - for example when we translate absoluteForm we need to pass
// excludeCurrentPeriod that is completely unrelated to absolute filter and is not used in absolute translations.
// So in the future, if there will be need for more metadata, consider adding wrapper union type that would wrap
// DateFilterOption along with additional metadata related to given filter. eg.:
// | { filter: IRelativeDateFilterPreset, excludeCurrentPeriod: boolean } |
// | { filter: IAbsoluteFilterForm } |
// ...
/**
 * Gets the filter title favoring custom name if specified.
 * @returns {string} Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
exports.getDateFilterTitle = function (filter, locale) {
    var translator = IntlStore_1.default.getIntl(locale);
    return getDateFilterRepresentationByFilterType(filter, translator);
};
/**
 * Gets the filter title favoring custom name if specified. This function is only for mock purpose.
 * @returns {string} Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
exports.getDateFilterTitleUsingTranslator = function (filter, translator) { return getDateFilterRepresentationByFilterType(filter, translator); };
/**
 * Gets the filter representation regardless of custom name.
 * @returns {string} Representation of the filter (e.g. "From 2 weeks ago to 1 week ahead")
 */
var getDateFilterRepresentationUsingTranslator = function (filter, translator) {
    if (typings_1.ExtendedDateFilters.isAbsoluteDateFilterForm(filter)) {
        return getAbsoluteFormFilterRepresentation(filter, translator);
    }
    else if (typings_1.ExtendedDateFilters.isAbsoluteDateFilterPreset(filter)) {
        return getAbsolutePresetFilterRepresentation(filter, translator);
    }
    else if (typings_1.ExtendedDateFilters.isAllTimeDateFilter(filter)) {
        return getAllTimeFilterRepresentation(translator);
    }
    else if (typings_1.ExtendedDateFilters.isRelativeDateFilterForm(filter)) {
        return getRelativeFormFilterRepresentation(filter, translator);
    }
    else if (typings_1.ExtendedDateFilters.isRelativeDateFilterPreset(filter)) {
        return getRelativePresetFilterRepresentation(filter, translator);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
exports.getDateFilterRepresentation = function (filter, locale) {
    var translator = IntlStore_1.default.getIntl(locale);
    return getDateFilterRepresentationUsingTranslator(filter, translator);
};
//# sourceMappingURL=DateFilterTitle.js.map
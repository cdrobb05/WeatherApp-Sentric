"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2019-2020 GoodData Corporation
var React = require("react");
var PropTypes = require("prop-types");
var react_window_1 = require("react-window");
var classnames_1 = require("classnames");
var lodash_1 = require("lodash");
var SelectOption_1 = require("./SelectOption");
var SelectHeading_1 = require("./SelectHeading");
var SelectSeparator_1 = require("./SelectSeparator");
var utils_1 = require("./utils");
exports.defaultVisibleItemsRange = 3;
var optionGetter = function (_a) {
    var items = _a.items, selectedItem = _a.selectedItem, highlightedIndex = _a.highlightedIndex, getItemProps = _a.getItemProps, optionClassName = _a.optionClassName;
    return function (_a) {
        var index = _a.index, style = _a.style;
        var selectableOptions = utils_1.getSelectableItems(items);
        var item = items[index];
        if (item.type === "option") {
            return (React.createElement(SelectOption_1.SelectOption, __assign({}, getItemProps({
                key: item.type + "-" + item.value,
                item: item,
                index: selectableOptions.indexOf(item),
                isSelected: selectedItem && item ? selectedItem.value === item.value : false,
                className: optionClassName,
            }), { isFocused: selectableOptions[highlightedIndex] && item
                    ? selectableOptions[highlightedIndex].value === item.value
                    : false, style: style }), item.label));
        }
        else if (item.type === "heading" || item.type === "error") {
            // for now errors look the same as headings
            return (React.createElement(SelectHeading_1.SelectHeading, { key: item.type + "-" + item.label, style: style }, item.label));
        }
        else if (item.type === "separator") {
            return React.createElement(SelectSeparator_1.SelectSeparator, { key: item.type + "-" + index, style: style });
        }
        return null;
    };
};
var itemHeightByTypeMap = {
    option: 32,
    heading: 22,
    error: 22,
    separator: 1,
};
exports.getItemHeight = function (items) { return function (index) {
    var itemType = items[index].type;
    return itemHeightByTypeMap[itemType];
}; };
exports.getMedianIndex = function (array) { return Math.floor(array.length / 2); };
var VirtualizedSelectMenu = /** @class */ (function (_super) {
    __extends(VirtualizedSelectMenu, _super);
    function VirtualizedSelectMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listRef = React.createRef();
        _this.scrollToIndex = function (index) {
            if (index === void 0) { index = _this.props.highlightedIndex; }
            if (_this.listRef.current) {
                var items = _this.props.items;
                var selectableOptions = utils_1.getSelectableItems(items);
                var optionIndex = index !== null ? index : exports.getMedianIndex(utils_1.getSelectableItems(items));
                var highlightedOption = selectableOptions[optionIndex];
                // highlightedIndex ignores non selectable items, but scrollToItem doesn't.
                var actualItemIndex = items.indexOf(highlightedOption);
                _this.listRef.current.scrollToItem(actualItemIndex, "center");
            }
        };
        _this.scrollToTop = function () {
            if (!_this.listRef.current) {
                return;
            }
            _this.listRef.current.scrollTo(0);
        };
        _this.componentDidUpdate = function (lastProps) {
            var _a = _this.props, highlightedIndex = _a.highlightedIndex, items = _a.items, setHighlightedIndex = _a.setHighlightedIndex, inputValue = _a.inputValue;
            var lastSelectibleLastItemIndex = utils_1.getSelectableItems(lastProps.items).length - 1;
            var selectiblelastItemIndex = utils_1.getSelectableItems(items).length - 1;
            var lastHighlightIsAtStart = lastProps.highlightedIndex === 0;
            var lastHighlightIsAtEnd = lastProps.highlightedIndex === lastSelectibleLastItemIndex;
            var highlightIsAtStart = highlightedIndex === 0;
            var highlightIsAtEnd = highlightedIndex === selectiblelastItemIndex;
            var isHighlightLoopedBack = lastHighlightIsAtStart && highlightIsAtEnd;
            var isHighlightLoopedForward = lastHighlightIsAtEnd && highlightIsAtStart;
            var isInputValueEmpty = inputValue.trim() === "";
            var isInputValueReset = lastProps.inputValue.trim() !== "" && isInputValueEmpty;
            var isInputValueChanged = lastProps.inputValue.trim() !== inputValue.trim();
            var medianIndex = exports.getMedianIndex(utils_1.getSelectableItems(items));
            if (isInputValueReset) {
                // We need to set highlight to medianIndex manually after clearing inputValue
                setHighlightedIndex(medianIndex);
            }
            else if (isInputValueChanged) {
                // We need to set highlight to 0 manually after filtering
                setHighlightedIndex(0);
            }
            var hasOnlyOneItem = _this.props.items.length === 1;
            if (isInputValueReset) {
                // We need to restore explicitly medianIndex scroll position immediately after inputValue reset
                // even though setHighlightedIndex(medianIndex) is called, because it takes effect after one tick
                _this.scrollToIndex(medianIndex);
            }
            else if (isHighlightLoopedBack || isHighlightLoopedForward) {
                _this.scrollToIndex();
            }
            else if (hasOnlyOneItem) {
                // if there is only one item, we need to explicitly scroll to top
                // in order to handle error messages being scrolled out of view
                _this.scrollToTop();
            }
        };
        return _this;
    }
    VirtualizedSelectMenu.prototype.render = function () {
        var _a = this.props, items = _a.items, selectedItem = _a.selectedItem, highlightedIndex = _a.highlightedIndex, getItemProps = _a.getItemProps, getMenuProps = _a.getMenuProps, className = _a.className, optionClassName = _a.optionClassName, visibleItemsRange = _a.visibleItemsRange;
        var Option = optionGetter({
            items: items,
            selectedItem: selectedItem,
            highlightedIndex: highlightedIndex,
            getItemProps: getItemProps,
            optionClassName: optionClassName,
        });
        var middleItemIndex = exports.getMedianIndex(utils_1.getSelectableItems(items));
        var visibleIndexes = lodash_1.range(Math.max(middleItemIndex - visibleItemsRange, 0), Math.min(middleItemIndex + visibleItemsRange + 1, items.length));
        var listHeight = visibleIndexes.reduce(function (totalHeight, itemIndex) { return totalHeight + exports.getItemHeight(items)(itemIndex); }, 0);
        return (React.createElement("div", __assign({}, getMenuProps({ className: classnames_1.default("gd-select-menu-wrapper", className) })),
            React.createElement("div", { className: "gd-select-menu s-select-menu" },
                React.createElement(react_window_1.VariableSizeList, { className: "List", ref: this.listRef, itemCount: items.length, itemSize: exports.getItemHeight(items), height: listHeight, width: "100%", overscanCount: 10, estimatedItemSize: itemHeightByTypeMap.option, 
                    // IE shows an unnecessary scrollbar when the list has only one item
                    // this means we have to explicitly disallow that
                    // we also cannot use className prop because react-window sets overflow using style
                    style: items.length === 1 ? { overflowY: "hidden" } : undefined }, Option))));
    };
    VirtualizedSelectMenu.prototype.componentDidMount = function () {
        if (!this.props.inputValue) {
            var medianIndex = exports.getMedianIndex(utils_1.getSelectableItems(this.props.items));
            this.props.setHighlightedIndex(medianIndex);
            this.scrollToIndex(medianIndex);
        }
        else {
            this.scrollToIndex();
        }
    };
    VirtualizedSelectMenu.propTypes = {
        selectedItem: PropTypes.shape({
            value: PropTypes.any.isRequired,
            label: PropTypes.any,
        }),
        items: PropTypes.array.isRequired,
        getItemProps: PropTypes.func.isRequired,
        getMenuProps: PropTypes.func.isRequired,
    };
    // static cannot have <V>
    VirtualizedSelectMenu.defaultProps = {
        selectedItem: null,
        visibleItemsRange: exports.defaultVisibleItemsRange,
    };
    return VirtualizedSelectMenu;
}(React.Component));
exports.VirtualizedSelectMenu = VirtualizedSelectMenu;
//# sourceMappingURL=VirtualizedSelectMenu.js.map
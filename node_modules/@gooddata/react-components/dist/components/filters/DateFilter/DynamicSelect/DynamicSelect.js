"use strict";
// (C) 2019 GoodData Corporation
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable member-ordering
var React = require("react");
var PropTypes = require("prop-types");
var noop = require("lodash/noop");
var downshift_1 = require("downshift");
var classnames_1 = require("classnames");
var utils_1 = require("../Select/utils");
var VirtualizedSelectMenu_1 = require("../Select/VirtualizedSelectMenu");
var utils_2 = require("./utils");
var DynamicSelect = /** @class */ (function (_super) {
    __extends(DynamicSelect, _super);
    function DynamicSelect(props) {
        var _this = _super.call(this, props) || this;
        _this.inputRef = React.createRef();
        _this.onChange = function (option) {
            if (option) {
                _this.props.onChange(option.value);
            }
        };
        _this.componentDidUpdate = function (lastProps) {
            if (lastProps.value !== _this.props.value) {
                var defaultItems = _this.props.getItems(_this.props.value.toString());
                var inputValue = utils_2.findRelativeDateFilterOptionByValue(defaultItems, _this.props.value).label;
                _this.setState({
                    inputValue: inputValue,
                });
            }
        };
        _this.focus = function () {
            if (_this.inputRef.current) {
                _this.inputRef.current.focus();
            }
        };
        _this.onInputValueChanged = function (inputValue) {
            if (inputValue !== _this.state.inputValue) {
                _this.setState({ inputValue: inputValue });
            }
        };
        var selectedItem = props.value !== undefined
            ? utils_2.findRelativeDateFilterOptionByValue(props.getItems(""), props.value)
            : null;
        _this.state = {
            inputValue: selectedItem ? utils_1.itemToString(selectedItem) : "",
        };
        return _this;
    }
    DynamicSelect.prototype.render = function () {
        var _this = this;
        var _a = this.props, initialIsOpen = _a.initialIsOpen, placeholder = _a.placeholder, getItems = _a.getItems, _b = _a.value, value = _b === void 0 ? null : _b, className = _a.className, style = _a.style, optionClassName = _a.optionClassName, visibleItemsRange = _a.visibleItemsRange;
        var items = getItems(this.state.inputValue);
        // this is important to correctly find out selected option. It is different than 'items'.
        var itemsByValue = value !== null ? getItems(value.toString()) : [];
        // Downshift requires null as empty selected item, if we would pass undefined it would change
        // from controlled to uncontrolled component
        var selectedItem = (value !== null && utils_2.findRelativeDateFilterOptionByValue(itemsByValue, value)) || null;
        var selectableItems = utils_1.getSelectableItems(items);
        var isFiltered = this.state.inputValue.trim() !== "";
        return (React.createElement(downshift_1.default, { onChange: this.onChange, itemToString: utils_1.itemToString, initialIsOpen: initialIsOpen, selectedItem: selectedItem, itemCount: selectableItems.length, inputValue: this.state.inputValue, 
            // automatically highlight (and therefore scroll to) the middle option if default items are displayed
            defaultHighlightedIndex: selectedItem || isFiltered ? 0 : VirtualizedSelectMenu_1.getMedianIndex(selectableItems) }, function (_a) {
            var getInputProps = _a.getInputProps, getMenuProps = _a.getMenuProps, getItemProps = _a.getItemProps, isOpen = _a.isOpen, openMenu = _a.openMenu, inputValue = _a.inputValue, highlightedIndex = _a.highlightedIndex, setHighlightedIndex = _a.setHighlightedIndex, selectItem = _a.selectItem;
            // Without this, highlight is not properly reset during filtering
            var effectiveHighlightedIndex = highlightedIndex > selectableItems.length - 1 ? 0 : highlightedIndex;
            var menuProps = {
                items: items,
                selectedItem: selectedItem,
                highlightedIndex: effectiveHighlightedIndex,
                getItemProps: getItemProps,
                getMenuProps: getMenuProps,
                className: "gd-dynamic-select-menu",
                optionClassName: optionClassName,
                inputValue: inputValue,
                setHighlightedIndex: setHighlightedIndex,
                visibleItemsRange: visibleItemsRange,
            };
            return (React.createElement("div", { className: classnames_1.default("gd-dynamic-select", className), style: style },
                React.createElement("div", { className: "gd-dynamic-select-input-wrapper" },
                    React.createElement("input", __assign({ type: "text", className: "s-relative-range-input gd-input-field" }, getInputProps({
                        ref: _this.inputRef,
                        placeholder: selectedItem ? selectedItem.label : placeholder,
                        value: inputValue,
                        onFocus: function () {
                            _this.setState({ inputValue: "" });
                            openMenu();
                        },
                        // Downshifts onInputValueChanged fires twice and with an old value
                        // So we need to use our own callback
                        onChange: function (event) {
                            return _this.onInputValueChanged(event.target.value);
                        },
                        onBlur: function () {
                            // reset to selected item on blur
                            selectItem(selectedItem);
                            _this.setState({
                                inputValue: selectedItem ? selectedItem.label : "",
                            });
                        },
                    })))),
                isOpen && React.createElement(VirtualizedSelectMenu_1.VirtualizedSelectMenu, __assign({}, menuProps))));
        }));
    };
    DynamicSelect.defaultProps = {
        onChange: noop,
        initialIsOpen: false,
        placeholder: undefined,
        value: undefined,
        className: undefined,
        style: undefined,
        visibleItemsRange: VirtualizedSelectMenu_1.defaultVisibleItemsRange,
    };
    DynamicSelect.propTypes = {
        getItems: PropTypes.func.isRequired,
        onChange: PropTypes.func,
        initialIsOpen: PropTypes.bool,
        placeholder: PropTypes.string,
        value: PropTypes.number,
        className: PropTypes.string,
        style: PropTypes.object,
        optionClassName: PropTypes.string,
    };
    return DynamicSelect;
}(React.Component));
exports.DynamicSelect = DynamicSelect;
//# sourceMappingURL=DynamicSelect.js.map
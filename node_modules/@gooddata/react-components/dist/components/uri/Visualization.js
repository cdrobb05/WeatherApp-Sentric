"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var gooddata_js_1 = require("@gooddata/gooddata-js");
var get = require("lodash/get");
var noop = require("lodash/noop");
var isEqual = require("lodash/isEqual");
var react_intl_1 = require("react-intl");
var IntlWrapper_1 = require("../core/base/IntlWrapper");
var BaseChart_1 = require("../core/base/BaseChart");
var PivotTable_1 = require("../PivotTable");
var GeoPushpinChart_1 = require("../GeoPushpinChart");
var Headline_1 = require("../core/Headline");
var Xirr_1 = require("../core/Xirr");
var Visualization_1 = require("../../proptypes/Visualization");
var visualizationTypes_1 = require("../../constants/visualizationTypes");
var common_1 = require("../../helpers/geoChart/common");
var visualizationType_1 = require("../../helpers/visualizationType");
var MdObjectHelper_1 = require("../../helpers/MdObjectHelper");
var measureTitleHelper_1 = require("../../helpers/measureTitleHelper");
var LoadingComponent_1 = require("../simple/LoadingComponent");
var ErrorComponent_1 = require("../simple/ErrorComponent");
var __1 = require("../../");
var utils_1 = require("../../helpers/utils");
var sorts_1 = require("../../helpers/sorts");
var errorHandlers_1 = require("../../helpers/errorHandlers");
var common_2 = require("../visualizations/utils/common");
var color_1 = require("../visualizations/utils/color");
var sdkCache_1 = require("../../helpers/sdkCache");
var featureFlags_1 = require("../../helpers/featureFlags");
var afmHelper_1 = require("../../helpers/afmHelper");
var experimentalDataSource_1 = require("./experimentalDataSource");
var propertiesHelper_1 = require("../../internal/utils/propertiesHelper");
var localization_1 = require("../../constants/localization");
var ExecuteAfmAdapter = gooddata_js_1.DataLayer.ExecuteAfmAdapter, toAfmResultSpec = gooddata_js_1.DataLayer.toAfmResultSpec, createSubject = gooddata_js_1.DataLayer.createSubject;
function uriResolver(sdk, projectId, uri, identifier) {
    if (uri) {
        return Promise.resolve(uri);
    }
    if (!identifier) {
        return Promise.reject("Neither uri or identifier specified");
    }
    return sdk.md.getObjectUri(projectId, identifier);
}
function fetchVisObject(sdk, visualizationUri) {
    return sdk.md.getVisualization(visualizationUri).then(function (res) { return res.visualizationObject; });
}
function fetchVisualizationClass(sdk, visualizationClassUri) {
    var apiCallIdentifier = "get." + visualizationClassUri;
    var loader = function () { return sdk.xhr.get(visualizationClassUri); };
    return sdkCache_1.getCachedOrLoad(apiCallIdentifier, loader).then(function (response) { return response.data.visualizationClass; });
}
function fetchLocalizationFromUser(sdk, projectId) {
    var apiCallIdentifier = "localizationFromUser." + projectId;
    var loader = function () { return sdk.user.getCurrentProfile(); };
    return sdkCache_1.getCachedOrLoad(apiCallIdentifier, loader)
        .then(function (response) { return response.language; })
        .catch(function (e) {
        // tslint:disable-next-line:no-console
        console.error(e);
        return new Promise(function (resolve) {
            resolve(localization_1.DEFAULT_LOCALE);
        });
    });
}
function getWidthDefs(mdObjectContentProperties) {
    return get(mdObjectContentProperties, ["controls", "columnWidths"]);
}
function getProperties(mdObject) {
    return mdObject.content && mdObject.content.properties && JSON.parse(mdObject.content.properties);
}
var VisualizationWrapped = /** @class */ (function (_super) {
    __extends(VisualizationWrapped, _super);
    function VisualizationWrapped(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            isLoading: true,
            type: null,
            resultSpec: null,
            totals: [],
            error: null,
            mdObject: null,
            colorPalette: null,
            colorPaletteEnabled: false,
            featureFlags: {},
        };
        _this.sdk = props.sdk ? props.sdk.clone() : gooddata_js_1.factory();
        utils_1.setTelemetryHeaders(_this.sdk, "Visualization", props);
        _this.isUnmounted = false;
        _this.visualizationUri = props.uri;
        _this.errorMap = errorHandlers_1.generateErrorMap(props.intl);
        _this.subject = createSubject(function (_a) {
            var type = _a.type, resultSpec = _a.resultSpec, dataSource = _a.dataSource, totals = _a.totals, mdObject = _a.mdObject, featureFlags = _a.featureFlags;
            _this.dataSource = dataSource;
            _this.setStateWithCheck({
                type: type,
                resultSpec: resultSpec,
                isLoading: false,
                totals: totals,
                mdObject: mdObject,
                featureFlags: featureFlags,
                error: null,
            });
        }, function (error) {
            var runtimeError = errorHandlers_1.convertErrors(error);
            _this.setStateWithCheck({
                isLoading: false,
                error: runtimeError,
            });
            sdkCache_1.clearSdkCache();
            return props.onError(runtimeError);
        });
        return _this;
    }
    VisualizationWrapped.prototype.componentDidMount = function () {
        var _a = this.props, projectId = _a.projectId, uri = _a.uri, identifier = _a.identifier, filters = _a.filters;
        this.adapter = new ExecuteAfmAdapter(this.sdk, projectId);
        this.visualizationUri = uri;
        this.subject.next(this.prepareDataSources(projectId, identifier, filters));
        this.getColorPalette();
    };
    VisualizationWrapped.prototype.componentWillUnmount = function () {
        this.subject.unsubscribe();
        this.isUnmounted = true;
    };
    VisualizationWrapped.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return (this.hasChangedProps(nextProps) ||
            this.state.isLoading !== nextState.isLoading ||
            (!this.state.colorPalette && nextState.colorPalette !== null));
    };
    VisualizationWrapped.prototype.hasChangedProps = function (nextProps, propKeys) {
        var _this = this;
        if (propKeys === void 0) { propKeys = Object.keys(Visualization_1.VisualizationPropType); }
        return propKeys.some(function (propKey) { return !isEqual(_this.props[propKey], nextProps[propKey]); });
    };
    VisualizationWrapped.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.sdk && this.props.sdk !== nextProps.sdk) {
            this.sdk = nextProps.sdk.clone();
            utils_1.setTelemetryHeaders(this.sdk, "Visualization", nextProps);
            this.getColorPalette();
        }
        var hasInvalidResolvedUri = this.hasChangedProps(nextProps, ["uri", "projectId", "identifier"]);
        var hasInvalidDatasource = hasInvalidResolvedUri || this.hasChangedProps(nextProps, ["filters"]);
        if (hasInvalidDatasource) {
            this.setStateWithCheck({
                isLoading: true,
            });
            if (hasInvalidResolvedUri) {
                this.visualizationUri = nextProps.uri;
            }
            this.subject.next(this.prepareDataSources(nextProps.projectId, nextProps.identifier, nextProps.filters));
            this.setState({ error: null });
        }
    };
    VisualizationWrapped.prototype.render = function () {
        var _a = this, dataSource = _a.dataSource, sdk = _a.sdk;
        var _b = this.props, afterRender = _b.afterRender, projectId = _b.projectId, drillableItems = _b.drillableItems, onFiredDrillEvent = _b.onFiredDrillEvent, onDrill = _b.onDrill, onLegendReady = _b.onLegendReady, onError = _b.onError, onLoadingChanged = _b.onLoadingChanged, BaseChartComponent = _b.BaseChartComponent, PivotTableComponent = _b.PivotTableComponent, GeoPushpinChartComponent = _b.GeoPushpinChartComponent, HeadlineComponent = _b.HeadlineComponent, XirrComponent = _b.XirrComponent, LoadingComponent = _b.LoadingComponent, ErrorComponent = _b.ErrorComponent, onExportReady = _b.onExportReady, filtersFromProps = _b.filters;
        var _c = this.state, resultSpec = _c.resultSpec, type = _c.type, error = _c.error, isLoading = _c.isLoading, mdObject = _c.mdObject;
        var locale = this.decideLocale;
        if (error) {
            return this.renderError(error);
        }
        else if (isLoading || !dataSource) {
            return LoadingComponent ? React.createElement(LoadingComponent, null) : null;
        }
        var config = this.createVisualizationConfig();
        var commonProps = {
            sdk: sdk,
            projectId: projectId,
            drillableItems: drillableItems,
            onFiredDrillEvent: onFiredDrillEvent,
            onDrill: onDrill,
            onError: onError,
            onLoadingChanged: onLoadingChanged,
            LoadingComponent: LoadingComponent,
            ErrorComponent: ErrorComponent,
            locale: locale,
            config: config,
            exportTitle: this.exportTitle,
            onExportReady: onExportReady,
        };
        var sourceProps = {
            resultSpec: resultSpec,
            dataSource: dataSource,
        };
        switch (type) {
            case visualizationTypes_1.VisualizationTypes.TABLE: {
                var processedVisualizationObject_1 = __assign({}, mdObject, { content: measureTitleHelper_1.fillMissingTitles(mdObject.content, locale) });
                this.exportTitle = get(processedVisualizationObject_1, "meta.title", "");
                var pivotBucketProps = MdObjectHelper_1.mdObjectToPivotBucketProps(processedVisualizationObject_1, filtersFromProps);
                var mdObjectContentProperties = getProperties(mdObject);
                var widthDefs = getWidthDefs(mdObjectContentProperties);
                var pivotTableColumnProps = {
                    config: featureFlags_1.getTableConfigFromFeatureFlags(config, this.state.featureFlags, false, widthDefs),
                };
                // we do not need to pass totals={totals} because BucketPivotTable deals with changes in totals itself
                return (React.createElement(PivotTableComponent, __assign({}, commonProps, pivotBucketProps, pivotTableColumnProps)));
            }
            case visualizationTypes_1.VisualizationTypes.PUSHPIN:
                var processedVisualizationObject = __assign({}, mdObject, { content: measureTitleHelper_1.fillMissingTitles(mdObject.content, locale) });
                var geoBucketProps = MdObjectHelper_1.mdObjectToGeoPushpinBucketProps(common_1.isGeoConfig(config) && config, processedVisualizationObject, filtersFromProps);
                return (React.createElement(GeoPushpinChartComponent, __assign({}, commonProps, geoBucketProps, { afterRender: afterRender })));
            case visualizationTypes_1.VisualizationTypes.HEADLINE:
                return React.createElement(HeadlineComponent, __assign({}, commonProps, sourceProps));
            case visualizationTypes_1.VisualizationTypes.XIRR:
                return React.createElement(XirrComponent, __assign({}, commonProps, sourceProps));
            default:
                return (React.createElement(BaseChartComponent, __assign({}, commonProps, sourceProps, { onLegendReady: onLegendReady, type: type })));
        }
    };
    VisualizationWrapped.prototype.prepareDataSources = function (projectId, identifier, filters) {
        if (filters === void 0) { filters = []; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, uriResolver, fetchVisObject, fetchVisualizationClass, locale, getFeatureFlags, _b, visualizationUri, featureFlags, localeFromUserAccount, mdObject, visualizationClassUri, visualizationClass, visualizationType, mdObjectContentProperties, secondaryYAxis, canSortStackTotalValue, sortingConfigs, _c, afm, resultSpec, mdObjectTotals, dataSource;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = this.props, uriResolver = _a.uriResolver, fetchVisObject = _a.fetchVisObject, fetchVisualizationClass = _a.fetchVisualizationClass, locale = _a.locale, getFeatureFlags = _a.getFeatureFlags;
                        return [4 /*yield*/, Promise.all([
                                uriResolver(this.sdk, projectId, this.visualizationUri, identifier),
                                getFeatureFlags(this.sdk, projectId),
                                fetchLocalizationFromUser(this.sdk, projectId),
                            ])];
                    case 1:
                        _b = _d.sent(), visualizationUri = _b[0], featureFlags = _b[1], localeFromUserAccount = _b[2];
                        return [4 /*yield*/, fetchVisObject(this.sdk, visualizationUri)];
                    case 2:
                        mdObject = _d.sent();
                        visualizationClassUri = MdObjectHelper_1.default.getVisualizationClassUri(mdObject);
                        return [4 /*yield*/, fetchVisualizationClass(this.sdk, visualizationClassUri)];
                    case 3:
                        visualizationClass = _d.sent();
                        return [4 /*yield*/, visualizationType_1.getVisualizationTypeFromVisualizationClass(visualizationClass)];
                    case 4:
                        visualizationType = _d.sent();
                        this.visualizationUri = visualizationUri;
                        this.decideLocale = locale ? locale : localeFromUserAccount;
                        this.exportTitle = get(mdObject, "meta.title", "");
                        mdObjectContentProperties = getProperties(mdObject);
                        secondaryYAxis = get(this.props.config, ["secondary_yaxis"], undefined) ||
                            get(mdObjectContentProperties, ["controls", "secondary_yaxis"], undefined);
                        canSortStackTotalValue = get(mdObjectContentProperties, ["controls", "stackMeasures"], false) &&
                            MdObjectHelper_1.areAllMeasuresOnSingleAxis(mdObject.content, secondaryYAxis);
                        sortingConfigs = {
                            canSortStackTotalValue: canSortStackTotalValue,
                            enableSortingByTotalGroup: featureFlags.enableSortingByTotalGroup,
                        };
                        _c = buildAfmResultSpec(mdObject.content, visualizationType, this.decideLocale, sortingConfigs), afm = _c.afm, resultSpec = _c.resultSpec;
                        mdObjectTotals = MdObjectHelper_1.default.getTotals(mdObject);
                        return [4 /*yield*/, this.createDataSource(afm, filters)];
                    case 5:
                        dataSource = _d.sent();
                        return [2 /*return*/, {
                                type: visualizationType,
                                dataSource: dataSource,
                                resultSpec: resultSpec,
                                totals: mdObjectTotals,
                                mdObject: mdObject,
                                featureFlags: featureFlags,
                            }];
                }
            });
        });
    };
    VisualizationWrapped.prototype.renderError = function (error) {
        var _a = this.props, intl = _a.intl, ErrorComponent = _a.ErrorComponent;
        var errorProps = this.errorMap[error.getMessage()];
        return ErrorComponent ? (React.createElement(ErrorComponent, __assign({ code: error.getMessage(), message: intl.formatMessage({ id: "visualization.ErrorMessageGeneric" }), description: intl.formatMessage({ id: "visualization.ErrorDescriptionGeneric" }) }, errorProps))) : null;
    };
    VisualizationWrapped.prototype.createVisualizationConfig = function () {
        var config = this.props.config;
        var _a = this.state, featureFlags = _a.featureFlags, mdObject = _a.mdObject, colorPalette = _a.colorPalette;
        return featureFlags_1.setConfigFromFeatureFlags(mergeChartConfigWithProperties(config, mdObject, colorPalette, featureFlags), featureFlags);
    };
    VisualizationWrapped.prototype.createDataSource = function (afm, filters) {
        var _a = this.props, projectId = _a.projectId, experimentalVisExecution = _a.experimentalVisExecution;
        if (experimentalVisExecution) {
            /*
             * using experimental executeVisualization endpoint allows server to apply additional security
             * measures on what is the client allowed to see/calculate.
             *
             * ideally, this factory would only take project+uri+filters => that is enough for the backend.
             *
             * however in practice, the returned data source MUST return valid AFM as this is later retrieved from the
             * dataSource and is used for various purposes (such as coloring the charts)
             *
             * We have ONE-3961 as followup to take this out of experimental mode.
             */
            return experimentalDataSource_1._experimentalDataSourceFactory(this.sdk, projectId, this.visualizationUri, afm, filters);
        }
        /*
         * the use of data source adapter leads to calls to execute AFM; custom filters for
         * the Visualization must be merged with AFM on the client-side
         *
         * we also need to sync the projectId to properly handle cases when projectId changes
         */
        this.adapter.projectId = projectId;
        return this.adapter.createDataSource(afmHelper_1.mergeFiltersToAfm(afm, filters));
    };
    VisualizationWrapped.prototype.hasExternalColorPalette = function () {
        return this.props.config && common_1.isChartConfig(this.props.config) && this.props.config.colorPalette;
    };
    VisualizationWrapped.prototype.hasColorsProp = function () {
        return this.props.config && common_1.isChartConfig(this.props.config) && this.props.config.colors;
    };
    VisualizationWrapped.prototype.getColorPaletteFromProject = function () {
        var _this = this;
        var apiCallIdentifier = "getColorPaletteWithGuids." + this.props.projectId;
        var loader = function () { return _this.sdk.project.getColorPaletteWithGuids(_this.props.projectId); };
        return sdkCache_1.getCachedOrLoad(apiCallIdentifier, loader);
    };
    VisualizationWrapped.prototype.getColorPalette = function () {
        return __awaiter(this, void 0, void 0, function () {
            var colorPalette;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.isUnmounted) return [3 /*break*/, 4];
                        if (!this.hasExternalColorPalette()) return [3 /*break*/, 1];
                        return [2 /*return*/];
                    case 1:
                        if (!this.hasColorsProp()) return [3 /*break*/, 2];
                        this.setStateWithCheck({
                            colorPalette: color_1.getColorPaletteFromColors(common_1.isChartConfig(this.props.config) && this.props.config.colors),
                        });
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.getColorPaletteFromProject()];
                    case 3:
                        colorPalette = _a.sent();
                        if (colorPalette) {
                            this.setStateWithCheck({ colorPalette: colorPalette });
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    VisualizationWrapped.prototype.setStateWithCheck = function (newState, callBack) {
        if (!this.isUnmounted) {
            this.setState(newState, callBack);
        }
    };
    VisualizationWrapped.propTypes = Visualization_1.VisualizationPropType;
    VisualizationWrapped.defaultProps = {
        onError: noop,
        onLegendReady: noop,
        filters: [],
        uriResolver: uriResolver,
        fetchVisObject: fetchVisObject,
        fetchVisualizationClass: fetchVisualizationClass,
        getFeatureFlags: featureFlags_1.getFeatureFlags,
        BaseChartComponent: BaseChart_1.BaseChart,
        PivotTableComponent: PivotTable_1.PivotTable,
        GeoPushpinChartComponent: GeoPushpinChart_1.GeoPushpinChart,
        HeadlineComponent: Headline_1.Headline,
        XirrComponent: Xirr_1.Xirr,
        ErrorComponent: ErrorComponent_1.ErrorComponent,
        LoadingComponent: LoadingComponent_1.LoadingComponent,
        onExportReady: noop,
        experimentalVisExecution: false,
    };
    return VisualizationWrapped;
}(React.Component));
exports.VisualizationWrapped = VisualizationWrapped;
/**
 * Given visualization object and type of visualization, this function builds AFM + ResultSpec combination
 * to be used for AFM Execution of the given vis object.
 *
 * The function ensures that any missing measure titles are filled in and that the ResultSpec matches the type of visualization.
 *
 * @param visObj content of visualization object
 * @param visType type of visualization - as recognized by SDK
 * @param locale locale to use when filling missing measure titles
 */
function buildAfmResultSpec(visObj, visType, locale, sortingConfigs) {
    var updatedVisObj = measureTitleHelper_1.fillMissingTitles(visObj, locale);
    // Ignore simple measures' titles to make sure afm response contains the up-to-date titles
    var ignoredMeasureTitlesVisObj = measureTitleHelper_1.ignoreTitlesForSimpleMeasures(updatedVisObj);
    var genericAfmResultSpec = toAfmResultSpec(ignoredMeasureTitlesVisObj);
    return buildAfmResultSpecForVis(ignoredMeasureTitlesVisObj, visType, genericAfmResultSpec, sortingConfigs);
}
function buildAfmResultSpecForVis(visObj, visType, afmResultSpec, sortingConfigs) {
    var resultSpecWithDimensions = __assign({}, afmResultSpec.resultSpec, { dimensions: __1.generateDimensions(visObj, visType) });
    var _a = sortingConfigs.canSortStackTotalValue, canSortStackTotalValue = _a === void 0 ? false : _a, _b = sortingConfigs.enableSortingByTotalGroup, enableSortingByTotalGroup = _b === void 0 ? false : _b;
    var barChartDefaultSorting = enableSortingByTotalGroup && common_2.isBarChart(visType)
        ? {
            sorts: sorts_1.getDefaultBarChartSort(afmResultSpec.afm, resultSpecWithDimensions, canSortStackTotalValue, enableSortingByTotalGroup),
        }
        : {};
    var treemapDefaultSorting = common_2.isTreemap(visType)
        ? {
            sorts: sorts_1.getDefaultTreemapSort(afmResultSpec.afm, resultSpecWithDimensions),
        }
        : {};
    var heatmapDefaultSorting = common_2.isHeatmap(visType)
        ? {
            sorts: sorts_1.getDefaultHeatmapSort(resultSpecWithDimensions),
        }
        : {};
    var resultSpec = __assign({}, resultSpecWithDimensions, barChartDefaultSorting, treemapDefaultSorting, heatmapDefaultSorting);
    return {
        afm: afmResultSpec.afm,
        resultSpec: resultSpec,
    };
}
/**
 * Given chart config and visualization object, this function will:
 * - merge chart customization contained within vis obj properties with the provided chart config
 * - apply chart coloring according to information in vis object properties
 *
 * Chart coloring will use palette included in the config; if there is no palette it will fall back to the
 * provided palette
 *
 * @param config base configuration of the chart
 * @param visObj content of visualization obtain that MAY contain properties to merge with the base configuration
 * @param fallbackPalette color palette to fall back to in case there is no palette stored in `config`
 * @returns new instance of IChartConfig
 */
function mergeChartConfigWithProperties(config, visObj, fallbackPalette, featureFlags) {
    var properties = getProperties(visObj);
    var propertiesControls = properties && properties.controls;
    var colorPalette = config && config.colorPalette ? config.colorPalette : fallbackPalette;
    var colorMapping = propertiesControls && propertiesControls.colorMapping
        ? propertiesControls.colorMapping.map(function (mapping) {
            var predicate = color_1.getColorMappingPredicate(mapping.id);
            return {
                predicate: predicate,
                color: mapping.color,
            };
        })
        : undefined;
    var propsWithHCAxisNameConfig = propertiesHelper_1.getHighchartsAxisNameConfiguration(propertiesControls, featureFlags.enableAxisNameConfiguration);
    return __assign({}, propsWithHCAxisNameConfig, { colorMapping: colorMapping }, config, { colorPalette: colorPalette, mdObject: visObj && visObj.content });
}
exports.IntlVisualization = react_intl_1.injectIntl(VisualizationWrapped);
/**
 * [Visualization](http://sdk.gooddata.com/gooddata-ui/docs/react_components.html#visualization)
 * is a component that renders saved visualization based on projectId and either identifier or uri
 */
var Visualization = /** @class */ (function (_super) {
    __extends(Visualization, _super);
    function Visualization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Visualization.prototype.render = function () {
        return (React.createElement(IntlWrapper_1.IntlWrapper, { locale: this.props.locale },
            React.createElement(exports.IntlVisualization, __assign({}, this.props))));
    };
    return Visualization;
}(React.PureComponent));
exports.Visualization = Visualization;
//# sourceMappingURL=Visualization.js.map
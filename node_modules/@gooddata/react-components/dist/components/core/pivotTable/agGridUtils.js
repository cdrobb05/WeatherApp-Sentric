"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var omit = require("lodash/omit");
var escape = require("lodash/escape");
var pickBy = require("lodash/pickBy");
var size = require("lodash/size");
var stringify = require("json-stable-stringify");
var invariant = require("invariant");
var typings_1 = require("@gooddata/typings");
var mappingHeader_1 = require("../../../helpers/mappingHeader");
var MappingHeader_1 = require("../../../interfaces/MappingHeader");
var agGridConst_1 = require("./agGridConst");
/*
 * Assorted utility functions used in our Pivot Table -> ag-grid integration.
 */
exports.sanitizeField = function (field) {
    // Identifiers can not contain a dot character, because AGGrid cannot handle it.
    // Alternatively, we could handle it with a custom renderer (works in RowLoadingElement).
    return field
        .replace(/\./g, agGridConst_1.DOT_PLACEHOLDER)
        .replace(new RegExp(agGridConst_1.FIELD_SEPARATOR, "g"), agGridConst_1.FIELD_SEPARATOR_PLACEHOLDER)
        .replace(new RegExp(agGridConst_1.ID_SEPARATOR, "g"), agGridConst_1.ID_SEPARATOR_PLACEHOLDER);
};
// returns [attributeId, attributeValueId]
// attributeValueId can be null if supplied with attribute uri instead of attribute value uri
exports.getIdsFromUri = function (uri, sanitize) {
    if (sanitize === void 0) { sanitize = true; }
    var _a = uri.match(/obj\/([^\/]*)(\/elements\?id=)?(.*)?$/), attributeId = _a[1], _b = _a[3], attributeValueId = _b === void 0 ? null : _b;
    return [attributeId, attributeValueId].map(function (id) {
        return id && sanitize ? exports.sanitizeField(id) : id;
    });
};
exports.getParsedFields = function (colId) {
    // supported colIds are 'a_2009', 'a_2009_4-a_2071_12', 'a_2009_4-a_2071_12-m_3'
    return colId.split(agGridConst_1.FIELD_SEPARATOR).map(function (field) { return field.split(agGridConst_1.ID_SEPARATOR); });
};
exports.colIdIsSimpleAttribute = function (colId) {
    var parsedFields = exports.getParsedFields(colId);
    return parsedFields[0].length === 2 && parsedFields[0][0] === "a";
};
exports.getRowNodeId = function (item) {
    return Object.keys(item.headerItemMap)
        .map(function (key) {
        var mappingHeader = item.headerItemMap[key];
        if (MappingHeader_1.isMappingHeaderTotal(mappingHeader)) {
            return "" + key + agGridConst_1.ID_SEPARATOR + mappingHeader.totalHeaderItem.name;
        }
        var uri = mappingHeader_1.getMappingHeaderUri(mappingHeader);
        var ids = exports.getIdsFromUri(uri);
        return "" + key + agGridConst_1.ID_SEPARATOR + ids[1];
    })
        .join(agGridConst_1.FIELD_SEPARATOR);
};
exports.getGridIndex = function (position, gridDistance) {
    return Math.floor(position / gridDistance);
};
exports.cellRenderer = function (params) {
    var isRowTotalOrSubtotal = params.data &&
        params.data.type &&
        (params.data.type === agGridConst_1.ROW_TOTAL || params.data.type === agGridConst_1.ROW_SUBTOTAL);
    var isActiveRowTotal = isRowTotalOrSubtotal && // short circuit for non row totals
        params.data &&
        params.data.rowTotalActiveMeasures &&
        params.data.rowTotalActiveMeasures.some(function (measureColId) {
            return params.colDef.field.endsWith(measureColId);
        });
    var formattedValue = isRowTotalOrSubtotal && !isActiveRowTotal && !params.value
        ? "" // inactive row total cells should be really empty (no "-") when they have no value (RAIL-1525)
        : escape(params.formatValue(params.value));
    var className = params.node.rowPinned === "top" ? "gd-sticky-header-value" : "s-value";
    return "<span class=\"" + className + "\">" + (formattedValue || "") + "</span>";
};
exports.getTreeLeaves = function (tree, getChildren) {
    if (getChildren === void 0) { getChildren = function (node) { return node && node.children; }; }
    var leaves = [];
    var nodes = Array.isArray(tree) ? tree.slice() : [tree];
    var node;
    var children;
    while (
    // tslint:disable:no-conditional-assignment ban-comma-operator
    ((node = nodes.shift()),
        (children = getChildren(node)),
        (children && children.length) || (leaves.push(node) && nodes.length))
    // tslint:enable:no-conditional-assignment ban-comma-operator
    ) {
        if (children) {
            nodes.push.apply(nodes, children);
        }
    }
    return leaves;
};
exports.indexOfTreeNode = function (node, tree, matchNode, getChildren, indexes) {
    if (matchNode === void 0) { matchNode = function (nodeA, nodeB) { return nodeA === nodeB; }; }
    if (getChildren === void 0) { getChildren = function (node) { return (node && node.children) || []; }; }
    if (indexes === void 0) { indexes = []; }
    var nodes = Array.isArray(tree) ? tree.slice() : [tree];
    for (var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {
        var currentNode = nodes[nodeIndex];
        // match current node
        if (matchNode(currentNode, node)) {
            return indexes.concat([nodeIndex]);
        }
        // check children
        var childrenMatchIndexes = exports.indexOfTreeNode(node, getChildren(currentNode), matchNode, getChildren, indexes.concat([
            nodeIndex,
        ]));
        if (childrenMatchIndexes !== null) {
            return childrenMatchIndexes;
        }
    }
    return null;
};
function isMeasureColumnReadyToRender(params, execution) {
    return Boolean(params && params.value !== undefined && execution && execution.executionResponse);
}
exports.isMeasureColumnReadyToRender = isMeasureColumnReadyToRender;
function getMeasureFormat(gridHeader, execution) {
    var headers = execution.executionResponse.dimensions[1].headers;
    var header = headers[headers.length - 1];
    if (!typings_1.Execution.isMeasureGroupHeader(header)) {
        throw new Error("Cannot get measure format from header " + Object.keys(header));
    }
    var measureIndex = gridHeader.measureIndex;
    return header.measureGroupHeader.items[measureIndex].measureHeaderItem.format;
}
exports.getMeasureFormat = getMeasureFormat;
function getSubtotalStyles(dimension) {
    if (!dimension || !dimension.totals) {
        return [];
    }
    var even = false;
    var subtotalStyles = dimension.itemIdentifiers.slice(1).map(function (attributeIdentifier) {
        var hasSubtotal = dimension.totals.some(function (total) { return total.attributeIdentifier === attributeIdentifier; });
        if (hasSubtotal) {
            even = !even;
            return even ? "even" : "odd";
        }
        return null;
    });
    // Grand total (first) has no styles
    return [null].concat(subtotalStyles);
}
exports.getSubtotalStyles = getSubtotalStyles;
function generateAgGridComponentKey(afm, rendererId) {
    var afmWithoutTotals = omit(afm, ["nativeTotals"]);
    return "agGridKey-" + stringify(afmWithoutTotals) + "-" + rendererId;
}
exports.generateAgGridComponentKey = generateAgGridComponentKey;
function getLastFieldType(fields) {
    var lastFieldType = fields[fields.length - 1][0];
    return lastFieldType;
}
exports.getLastFieldType = getLastFieldType;
function getLastFieldId(fields) {
    var _a = fields[fields.length - 1], lastFieldId = _a[1];
    return lastFieldId;
}
exports.getLastFieldId = getLastFieldId;
function getAttributeLocators(fields, attributeHeaders) {
    return fields.slice(0, -1).map(function (field) {
        // first item is type which should be always 'a'
        var fieldId = field[1], fieldValueId = field[2];
        var attributeHeaderMatch = attributeHeaders.find(function (attributeHeader) {
            return exports.getIdsFromUri(attributeHeader.attributeHeader.formOf.uri)[0] === fieldId;
        });
        invariant(attributeHeaderMatch, "Could not find matching attribute header to field " + field.join(agGridConst_1.ID_SEPARATOR));
        return {
            attributeLocatorItem: {
                attributeIdentifier: attributeHeaderMatch.attributeHeader.localIdentifier,
                element: attributeHeaderMatch.attributeHeader.formOf.uri + "/elements?id=" + fieldValueId,
            },
        };
    });
}
exports.getAttributeLocators = getAttributeLocators;
exports.getColumnIdentifierFromDef = function (colDef) {
    // field should be always present, fallback to colId could happen for empty columns
    return colDef.field || colDef.colId;
};
exports.getColumnIdentifier = function (item) {
    if (isColumn(item)) {
        return exports.getColumnIdentifierFromDef(item.getColDef());
    }
    return exports.getColumnIdentifierFromDef(item);
};
function isColumn(item) {
    return !!item.getColDef;
}
exports.isColumn = isColumn;
exports.isMeasureColumn = function (item) {
    if (isColumn(item)) {
        return item.getColDef().type === agGridConst_1.MEASURE_COLUMN;
    }
    return item.type === agGridConst_1.MEASURE_COLUMN;
};
// ONE-4508 (bugfix) - in AFM object are presents empty arrays and therefore is necessary to sanitize
exports.sanitizeFingerprint = function (fingerprint) {
    var parsedFingerprint;
    try {
        parsedFingerprint = JSON.parse(fingerprint);
    }
    catch (_a) {
        console.error("unable to parse fingerprint"); // tslint:disable-line
    }
    if (!parsedFingerprint) {
        return fingerprint;
    }
    var parsedFingerprintAfm = __assign({}, parsedFingerprint.afm);
    var sanitizedParsedFingerprintAfm = pickBy(parsedFingerprintAfm, size);
    return JSON.stringify(__assign({}, parsedFingerprint, { afm: sanitizedParsedFingerprintAfm }));
};
exports.isColumnDisplayed = function (displayedColumns, column) {
    return displayedColumns.some(function (displayedColumn) { return displayedColumn.getColId() === column.getColId(); });
};
var getMappingHeaderMeasureItem = function (item) {
    if (!exports.isMeasureColumn(item)) {
        return;
    }
    var headers = isColumn(item)
        ? item.getColDef().drillItems
        : item.drillItems;
    if (headers) {
        return headers.filter(MappingHeader_1.isMappingHeaderMeasureItem)[0];
    }
};
exports.getMappingHeaderMeasureItemLocalIdentifier = function (item) {
    var measure = getMappingHeaderMeasureItem(item);
    if (measure) {
        return measure.measureHeaderItem.localIdentifier;
    }
};
//# sourceMappingURL=agGridUtils.js.map
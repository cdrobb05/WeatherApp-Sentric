"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var typings_1 = require("@gooddata/typings");
var agGridUtils_1 = require("./agGridUtils");
var agGridConst_1 = require("./agGridConst");
var agGridHeaders_1 = require("./agGridHeaders");
var invariant = require("invariant");
/*
 * All code related to sorting the ag-grid backed Pivot Table is concentrated here
 */
exports.getAttributeSortItemFieldAndDirection = function (sortItem, attributeHeaders) {
    var localIdentifier = sortItem.attributeSortItem.attributeIdentifier;
    var sortHeader = attributeHeaders.find(function (header) { return header.attributeHeader.localIdentifier === localIdentifier; });
    invariant(sortHeader, "Could not find sortHeader with localIdentifier " + localIdentifier);
    var field = agGridHeaders_1.identifyResponseHeader(sortHeader);
    return [field, sortItem.attributeSortItem.direction];
};
exports.getMeasureSortItemFieldAndDirection = function (sortItem, measureHeaderItems) {
    var keys = [];
    sortItem.measureSortItem.locators.forEach(function (locator) {
        if (typings_1.AFM.isMeasureLocatorItem(locator)) {
            var measureSortHeaderIndex = measureHeaderItems.findIndex(function (measureHeaderItem) {
                return measureHeaderItem.measureHeaderItem.localIdentifier ===
                    locator.measureLocatorItem.measureIdentifier;
            });
            keys.push("m" + agGridConst_1.ID_SEPARATOR + measureSortHeaderIndex);
        }
        else {
            var key = "a" + agGridConst_1.ID_SEPARATOR + agGridUtils_1.getIdsFromUri(locator.attributeLocatorItem.element).join(agGridConst_1.ID_SEPARATOR);
            keys.push(key);
        }
    });
    var field = keys.join(agGridConst_1.FIELD_SEPARATOR);
    var direction = sortItem.measureSortItem.direction;
    return [field, direction];
};
exports.getSortItemByColId = function (execution, colId, direction, originalSortItems) {
    var dimensions = execution.executionResponse.dimensions;
    var fields = agGridUtils_1.getParsedFields(colId);
    var lastFieldType = agGridUtils_1.getLastFieldType(fields);
    var lastFieldId = agGridUtils_1.getLastFieldId(fields);
    // search columns first when sorting in columns to use the proper header
    // in case the same attribute is in both rows and columns
    var searchDimensionIndex = lastFieldType === agGridConst_1.FIELD_TYPE_MEASURE ? 1 : 0;
    var _a = agGridHeaders_1.assortDimensionHeaders([
        dimensions[searchDimensionIndex],
    ]), attributeHeaders = _a.attributeHeaders, measureHeaderItems = _a.measureHeaderItems;
    if (lastFieldType === agGridConst_1.FIELD_TYPE_ATTRIBUTE) {
        var _loop_1 = function (header) {
            if (agGridUtils_1.getIdsFromUri(header.attributeHeader.uri)[0] === lastFieldId) {
                var attributeIdentifier_1 = header.attributeHeader.localIdentifier;
                // try to find the original sort item in case it had an aggregation set so we can keep it in (RAIL-1992)
                // we intentionally ignore the direction to make sure the UX is predictable
                var matchingOriginalSortItem = originalSortItems.find(function (s) {
                    return typings_1.AFM.isAttributeSortItem(s) &&
                        s.attributeSortItem.attributeIdentifier === attributeIdentifier_1;
                });
                var aggregationProp = matchingOriginalSortItem && matchingOriginalSortItem.attributeSortItem.aggregation
                    ? { aggregation: matchingOriginalSortItem.attributeSortItem.aggregation }
                    : {};
                return { value: {
                        attributeSortItem: __assign({ direction: direction,
                            attributeIdentifier: attributeIdentifier_1 }, aggregationProp),
                    } };
            }
        };
        for (var _i = 0, attributeHeaders_1 = attributeHeaders; _i < attributeHeaders_1.length; _i++) {
            var header = attributeHeaders_1[_i];
            var state_1 = _loop_1(header);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        invariant(false, "could not find attribute header matching " + colId);
    }
    else if (lastFieldType === agGridConst_1.FIELD_TYPE_MEASURE) {
        var headerItem = measureHeaderItems[parseInt(lastFieldId, 10)];
        var attributeLocators = agGridUtils_1.getAttributeLocators(fields, attributeHeaders);
        return {
            measureSortItem: {
                direction: direction,
                locators: attributeLocators.concat([
                    {
                        measureLocatorItem: {
                            measureIdentifier: headerItem.measureHeaderItem.localIdentifier,
                        },
                    },
                ]),
            },
        };
    }
    invariant(false, "could not find header matching " + colId);
};
function isSortedByFirstAttibute(columnDefs, resultSpec) {
    var sortedColumnIndexes = columnDefs.reduce(function (sortStack, columnDef, columnIndex) {
        if (columnDef.sort) {
            sortStack.all.push(columnIndex);
            if (columnDef.type === agGridConst_1.ROW_ATTRIBUTE_COLUMN) {
                sortStack.attributes.push(columnIndex);
            }
        }
        return sortStack;
    }, { attributes: [], all: [] });
    var sortedByFirstAttribute = sortedColumnIndexes.attributes[0] === 0 && sortedColumnIndexes.all.length === 1;
    var isSorted = sortedColumnIndexes.all.length > 0 || (resultSpec && resultSpec.sorts && resultSpec.sorts.length > 0);
    return sortedByFirstAttribute || !isSorted;
}
exports.isSortedByFirstAttibute = isSortedByFirstAttibute;
exports.getSortsFromModel = function (sortModel, // AgGrid has any, but we can do better
execution, originalSortItems) {
    if (originalSortItems === void 0) { originalSortItems = []; }
    return sortModel.map(function (sortModelItem) {
        var colId = sortModelItem.colId, sort = sortModelItem.sort;
        var sortHeader = exports.getSortItemByColId(execution, colId, sort, originalSortItems);
        invariant(sortHeader, "unable to find sort item by field " + colId);
        return sortHeader;
    });
};
exports.assignSorting = function (colDef, sortingMap) {
    var direction = sortingMap[colDef.field];
    if (direction) {
        colDef.sort = direction;
    }
};
//# sourceMappingURL=agGridSorting.js.map
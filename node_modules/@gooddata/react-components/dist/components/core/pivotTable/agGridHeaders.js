"use strict";
// (C) 2007-2020 GoodData Corporation
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var typings_1 = require("@gooddata/typings");
var mappingHeader_1 = require("../../../helpers/mappingHeader");
var utils_1 = require("../../../helpers/utils");
var agGridUtils_1 = require("./agGridUtils");
var range = require("lodash/range");
var clone = require("lodash/clone");
var agGridConst_1 = require("./agGridConst");
var agGridDrilling_1 = require("./agGridDrilling");
var invariant = require("invariant");
/*
 * All code related to transforming headers from our backend to ag-grid specific data structures
 */
exports.identifyHeader = function (header) {
    if (typings_1.Execution.isAttributeHeaderItem(header)) {
        return "a" + agGridConst_1.ID_SEPARATOR + agGridUtils_1.getIdsFromUri(header.attributeHeaderItem.uri).join(agGridConst_1.ID_SEPARATOR);
    }
    if (typings_1.Execution.isMeasureHeaderItem(header)) {
        return "m" + agGridConst_1.ID_SEPARATOR + header.measureHeaderItem.order;
    }
    if (typings_1.Execution.isTotalHeaderItem(header)) {
        return "t" + agGridConst_1.ID_SEPARATOR + header.totalHeaderItem.type;
    }
    invariant(false, "Unknown header type: " + JSON.stringify(header));
};
exports.identifyResponseHeader = function (header) {
    if (typings_1.Execution.isAttributeHeader(header)) {
        // response headers have no value id
        return "a" + agGridConst_1.ID_SEPARATOR + agGridUtils_1.getIdsFromUri(header.attributeHeader.uri)[0];
    }
    if (typings_1.Execution.isMeasureGroupHeader(header)) {
        // trying to identify a measure group would be ambiguous
        return null;
    }
    invariant(false, "Unknown response header type: " + JSON.stringify(header));
};
exports.headerToGrid = function (header, fieldPrefix) {
    if (fieldPrefix === void 0) { fieldPrefix = ""; }
    var internalHeader = utils_1.unwrap(header);
    return {
        headerName: internalHeader.name,
        field: fieldPrefix + exports.identifyHeader(header),
    };
};
exports.shouldMergeHeaders = function (resultHeaderDimension, headerIndex, headerItemIndex) {
    for (var ancestorIndex = headerIndex; ancestorIndex >= 0; ancestorIndex--) {
        var currentAncestorHeader = resultHeaderDimension[ancestorIndex][headerItemIndex];
        var nextAncestorHeader = resultHeaderDimension[ancestorIndex][headerItemIndex + 1];
        if (!nextAncestorHeader ||
            exports.identifyHeader(currentAncestorHeader) !== exports.identifyHeader(nextAncestorHeader)) {
            return false;
        }
    }
    return true;
};
exports.mergeHeaderEndIndex = function (resultHeaderDimension, headerIndex, headerItemStartIndex) {
    var header = resultHeaderDimension[headerIndex];
    for (var headerItemIndex = headerItemStartIndex; headerItemIndex < header.length; headerItemIndex++) {
        if (!exports.shouldMergeHeaders(resultHeaderDimension, headerIndex, headerItemIndex)) {
            return headerItemIndex;
        }
    }
    return headerItemStartIndex;
};
/*
 * getColumnHeaders transforms header items from matrix to tree hierarchy
 *Â for each span of identical headers in a row, the function is called recursively to assign child items
 */
exports.getColumnHeaders = function (resultHeaderDimension, responseHeaders, columnDefOptions, headerIndex, headerItemStartIndex, headerValueEnd, fieldPrefix, parentDrillItems) {
    if (columnDefOptions === void 0) { columnDefOptions = {}; }
    if (headerIndex === void 0) { headerIndex = 0; }
    if (headerItemStartIndex === void 0) { headerItemStartIndex = 0; }
    if (headerValueEnd === void 0) { headerValueEnd = undefined; }
    if (fieldPrefix === void 0) { fieldPrefix = ""; }
    if (parentDrillItems === void 0) { parentDrillItems = []; }
    if (!resultHeaderDimension.length) {
        return [];
    }
    var currentHeaders = resultHeaderDimension[headerIndex];
    var lastIndex = headerValueEnd !== undefined ? headerValueEnd : currentHeaders.length - 1;
    var hierarchy = [];
    for (var headerItemIndex = headerItemStartIndex; headerItemIndex < lastIndex + 1;) {
        var currentHeader = currentHeaders[headerItemIndex];
        var header = __assign({ drillItems: [] }, exports.headerToGrid(currentHeader, fieldPrefix), columnDefOptions);
        var drillItems = clone(parentDrillItems);
        agGridDrilling_1.assignDrillItemsAndType(header, currentHeader, responseHeaders, headerIndex, drillItems);
        var headerItemEndIndex = exports.mergeHeaderEndIndex(resultHeaderDimension, headerIndex, headerItemIndex);
        if (headerIndex !== resultHeaderDimension.length - 1) {
            header.children = exports.getColumnHeaders(resultHeaderDimension, responseHeaders, columnDefOptions, headerIndex + 1, headerItemIndex, headerItemEndIndex, header.field + agGridConst_1.FIELD_SEPARATOR, drillItems);
        }
        hierarchy.push(header);
        // We move the pointer manually to skip identical headers
        headerItemIndex = headerItemEndIndex + 1;
    }
    return hierarchy;
};
exports.getRowHeaders = function (rowDimensionHeaders, columnDefOptions, makeRowGroups) {
    return rowDimensionHeaders.map(function (attributeHeader) {
        var rowGroupProps = makeRowGroups
            ? {
                rowGroup: true,
                hide: true,
            }
            : {};
        var field = exports.identifyResponseHeader(attributeHeader);
        return __assign({ 
            // The label should be attribute name (not attribute display form name)
            headerName: mappingHeader_1.getMappingHeaderName(attributeHeader), type: agGridConst_1.ROW_ATTRIBUTE_COLUMN, 
            // Row dimension must contain only attribute headers.
            field: field, drillItems: [attributeHeader] }, rowGroupProps, columnDefOptions);
    });
};
exports.getFields = function (dataHeaders) {
    return range((dataHeaders[0] || []).length).map(function (cellIndex) {
        var fieldList = dataHeaders.map(function (header) {
            return exports.identifyHeader(header[cellIndex]);
        });
        return fieldList.join(agGridConst_1.FIELD_SEPARATOR);
    });
};
exports.assortDimensionHeaders = function (dimensions) {
    var dimensionHeaders = dimensions.reduce(function (headers, dimension) { return headers.concat(dimension.headers); }, []);
    var attributeHeaders = [];
    var measureHeaderItems = [];
    dimensionHeaders.forEach(function (dimensionHeader) {
        if (typings_1.Execution.isAttributeHeader(dimensionHeader)) {
            attributeHeaders.push(dimensionHeader);
        }
        else if (typings_1.Execution.isMeasureGroupHeader(dimensionHeader)) {
            measureHeaderItems.push.apply(measureHeaderItems, dimensionHeader.measureGroupHeader.items);
        }
    });
    return {
        attributeHeaders: attributeHeaders,
        measureHeaderItems: measureHeaderItems,
    };
};
exports.getMinimalRowData = function (data, rowHeaderItems) {
    var numberOfRowHeaderItems = (rowHeaderItems[0] || []).length;
    return data.length > 0
        ? data
        : // if there are no measures only attributes
            // create array of [null] of length equal to the number of row dimension headerItems
            Array(numberOfRowHeaderItems).fill([null]);
};
//# sourceMappingURL=agGridHeaders.js.map
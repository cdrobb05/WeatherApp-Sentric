"use strict";
// (C) 2007-2020 GoodData Corporation
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var typings_1 = require("@gooddata/typings");
var afmHelper_1 = require("../../../helpers/afmHelper");
var mappingHeader_1 = require("../../../helpers/mappingHeader");
var get = require("lodash/get");
var DrillEvents_1 = require("../../../interfaces/DrillEvents");
var MappingHeader_1 = require("../../../interfaces/MappingHeader");
var common_1 = require("../../visualizations/utils/common");
var drilldownEventing_1 = require("../../visualizations/utils/drilldownEventing");
var agGridUtils_1 = require("./agGridUtils");
var agGridConst_1 = require("./agGridConst");
exports.getDrillRowData = function (leafColumnDefs, rowData) {
    return leafColumnDefs.reduce(function (drillRow, colDef) {
        var type = colDef.type;
        // colDef without field is a utility column (e.g. top column label)
        if (colDef.field) {
            if (type === agGridConst_1.MEASURE_COLUMN) {
                return drillRow.concat([rowData[colDef.field]]);
            }
            var drillItem = get(rowData, ["headerItemMap", colDef.field]);
            if (drillItem && (type === agGridConst_1.COLUMN_ATTRIBUTE_COLUMN || type === agGridConst_1.ROW_ATTRIBUTE_COLUMN)) {
                var drillItemUri = mappingHeader_1.getMappingHeaderUri(drillItem);
                return drillRow.concat([
                    {
                        // Unlike fields, drilling data should not be sanitized, because it is not used in HTML properties
                        id: agGridUtils_1.getIdsFromUri(drillItemUri, false)[1],
                        name: rowData[colDef.field],
                    },
                ]);
            }
        }
        return drillRow;
    }, []);
};
var isDrillingOnMeasure = function (measureIndex) { return measureIndex !== -1; };
var skipRowAttributes = function (measureIndex) { return function (index) {
    return isDrillingOnMeasure(measureIndex) && index > measureIndex;
}; };
var getMeasurePositionInsideIntersection = function (intersection) {
    return intersection.findIndex(function (intersectionElement) {
        return DrillEvents_1.isMappingMeasureHeaderItem(intersectionElement.header);
    });
};
exports.convertPivotTableDrillContextToLegacy = function (drillContext, executionContext) {
    return __assign({}, drillContext, { intersection: exports.convertDrillIntersectionToLegacy(drillContext.intersection, executionContext) });
};
exports.convertDrillIntersectionToLegacy = function (intersectionExtended, afm) {
    // structure for new intersection when drilling on measure cell
    // [0..n] column attribute+item header
    // [1] measure header
    // [0..n] row attribute+item header - these needs to be removed during conversion to be backward compatible
    var measureIndex = getMeasurePositionInsideIntersection(intersectionExtended);
    var drillingOnMeasure = isDrillingOnMeasure(measureIndex);
    var shouldSkipRowAttributes = skipRowAttributes(measureIndex);
    var drillItems = intersectionExtended.reduce(function (drillItems, intersectionElement, index) {
        if (shouldSkipRowAttributes(index)) {
            // skip new row attributes in legacy intersection
            return drillItems;
        }
        if (DrillEvents_1.isDrillIntersectionAttributeItem(intersectionElement.header)) {
            var _a = intersectionElement.header, attributeHeader = _a.attributeHeader, attributeHeaderItem = _a.attributeHeaderItem;
            if (drillingOnMeasure) {
                // different item/attribute order for drilling on measure and drilling on attr :(
                drillItems.push({ attributeHeaderItem: attributeHeaderItem });
                drillItems.push({ attributeHeader: attributeHeader });
            }
            else {
                drillItems.push({ attributeHeader: attributeHeader });
                drillItems.push({ attributeHeaderItem: attributeHeaderItem });
            }
        }
        else {
            drillItems.push(intersectionElement.header);
        }
        return drillItems;
    }, []);
    // Drilling needs refactoring: all '' should be replaced by null (breaking change)
    // intersection consists of
    //     0..1 measure
    //     0..1 row attribute and row attribute value
    //     0..n column attribute and column attribute values
    return drillItems.map(function (drillItem) {
        if (MappingHeader_1.isMappingHeaderAttributeItem(drillItem)) {
            var id_1 = common_1.getAttributeElementIdFromAttributeElementUri(drillItem.attributeHeaderItem.uri);
            return drilldownEventing_1.createDrillIntersectionElement(id_1, mappingHeader_1.getMappingHeaderName(drillItem), mappingHeader_1.getMappingHeaderUri(drillItem), "");
        }
        var headerLocalIdentifier = mappingHeader_1.getMappingHeaderLocalIdentifier(drillItem);
        var headerIdentifier = mappingHeader_1.getMappingHeaderIdentifier(drillItem) || "";
        var uriAndIdentifier = headerLocalIdentifier
            ? afmHelper_1.getMasterMeasureObjQualifier(afm, headerLocalIdentifier)
            : null;
        var headerUri = mappingHeader_1.getMappingHeaderUri(drillItem) || "";
        var uri = (uriAndIdentifier && uriAndIdentifier.uri) || headerUri;
        var identifier = (uriAndIdentifier && uriAndIdentifier.identifier) || headerIdentifier;
        var id = headerLocalIdentifier || headerIdentifier;
        return drilldownEventing_1.createDrillIntersectionElement(id, mappingHeader_1.getMappingHeaderName(drillItem), uri, identifier);
    });
};
exports.getMeasureDrillItem = function (responseHeaders, header) {
    var measureGroupHeader = responseHeaders.find(function (responseHeader) {
        return typings_1.Execution.isMeasureGroupHeader(responseHeader);
    });
    return get(measureGroupHeader, ["measureGroupHeader", "items", header.measureHeaderItem.order], null);
};
exports.assignDrillItemsAndType = function (header, currentHeader, responseHeaders, headerIndex, drillItems) {
    if (typings_1.Execution.isAttributeHeaderItem(currentHeader)) {
        header.type = agGridConst_1.COLUMN_ATTRIBUTE_COLUMN;
        // attribute value uri
        drillItems.push(currentHeader);
        // attribute uri and identifier
        var attributeResponseHeader = responseHeaders[headerIndex % responseHeaders.length];
        drillItems.push(attributeResponseHeader);
        // This is where we could assign drillItems if we want to start drilling on column headers
        // It needs to have an empty array for some edge cases like column attributes without measures
    }
    else if (typings_1.Execution.isMeasureHeaderItem(currentHeader)) {
        // measure uri and identifier
        header.type = agGridConst_1.MEASURE_COLUMN;
        drillItems.push(exports.getMeasureDrillItem(responseHeaders, currentHeader));
        header.drillItems = drillItems;
        header.measureIndex = currentHeader.measureHeaderItem.order;
    }
};
//# sourceMappingURL=agGridDrilling.js.map
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var typings_1 = require("@gooddata/typings");
var mappingHeader_1 = require("../../../helpers/mappingHeader");
var agGridUtils_1 = require("./agGridUtils");
var agGridConst_1 = require("./agGridConst");
var agGridSorting_1 = require("./agGridSorting");
var agGridHeaders_1 = require("./agGridHeaders");
var agGridData_1 = require("./agGridData");
var agGridDataSourceUtils_1 = require("./agGridDataSourceUtils");
exports.getDataSourceRowsGetter = function (resultSpec, getPage, getExecution, onSuccess, getGridApi, intl, columnTotals, getGroupingProvider) {
    return function (getRowsParams) {
        var startRow = getRowsParams.startRow, endRow = getRowsParams.endRow, successCallback = getRowsParams.successCallback, failCallback = getRowsParams.failCallback, sortModel = getRowsParams.sortModel;
        if (agGridDataSourceUtils_1.isInvalidGetRowsRequest(startRow, getGridApi())) {
            failCallback();
            return Promise.resolve(null);
        }
        var execution = getExecution();
        var groupingProvider = getGroupingProvider();
        var resultSpecUpdated = resultSpec;
        // If execution is null, this means this is a fresh dataSource and we should ignore current sortModel
        if (sortModel.length > 0 && execution) {
            resultSpecUpdated = __assign({}, resultSpecUpdated, { sorts: agGridSorting_1.getSortsFromModel(sortModel, execution, resultSpec.sorts || []) });
        }
        if (columnTotals && columnTotals.length > 0) {
            resultSpecUpdated = __assign({}, resultSpecUpdated, { dimensions: [
                    __assign({}, resultSpecUpdated.dimensions[0], { totals: columnTotals })
                ].concat(resultSpecUpdated.dimensions.slice(1)) });
        }
        var pagePromise = getPage(resultSpecUpdated, 
        // column limit defaults to SERVERSIDE_COLUMN_LIMIT (1000), because 1000 columns is hopefully enough.
        [endRow - startRow, undefined], 
        // column offset defaults to 0, because we do not support horizontal paging yet
        [startRow, undefined]);
        return pagePromise.then(function (execution) {
            if (!execution) {
                return null;
            }
            var _a = exports.executionToAGGridAdapter(execution, resultSpecUpdated, intl, {
                addLoadingRenderer: "loadingRenderer",
            }), columnDefs = _a.columnDefs, rowData = _a.rowData, rowTotals = _a.rowTotals;
            var _b = execution.executionResult.paging, offset = _b.offset, count = _b.count, total = _b.total;
            var rowAttributeIds = columnDefs
                .filter(function (columnDef) { return columnDef.type === agGridConst_1.ROW_ATTRIBUTE_COLUMN; })
                .map(function (columnDef) { return columnDef.field; });
            groupingProvider.processPage(rowData, offset[0], rowAttributeIds);
            // RAIL-1130: Backend returns incorrectly total: [1, N], when count: [0, N] and offset: [0, N]
            var lastRow = offset[0] === 0 && count[0] === 0 ? 0 : total[0];
            onSuccess(execution, columnDefs, resultSpecUpdated);
            successCallback(rowData, lastRow);
            // set totals
            if (agGridDataSourceUtils_1.areTotalsChanged(getGridApi(), rowTotals)) {
                getGridApi().setPinnedBottomRowData(rowTotals);
            }
            return execution;
        });
    };
};
exports.executionToAGGridAdapter = function (executionResponses, resultSpec, intl, options) {
    if (resultSpec === void 0) { resultSpec = {}; }
    if (options === void 0) { options = {}; }
    var _a = options.makeRowGroups, makeRowGroups = _a === void 0 ? false : _a, _b = options.addLoadingRenderer, addLoadingRenderer = _b === void 0 ? null : _b, columnDefOptions = options.columnDefOptions;
    var dimensions = executionResponses.executionResponse.dimensions, _c = executionResponses.executionResult, data = _c.data, headerItems = _c.headerItems, totals = _c.totals;
    var columnAttributeHeaderCount = dimensions[1].headers.filter(function (header) { return !!header.attributeHeader; }).length;
    var columnHeaders = agGridHeaders_1.getColumnHeaders(headerItems[1], dimensions[1].headers, columnDefOptions);
    var groupColumnHeaders = columnAttributeHeaderCount > 0
        ? [
            {
                headerName: dimensions[1].headers
                    .filter(function (header) { return typings_1.Execution.isAttributeHeader(header); })
                    .map(function (header) {
                    return mappingHeader_1.getMappingHeaderName(header);
                })
                    .filter(function (item) { return item !== null; })
                    .join(agGridConst_1.COLUMN_GROUPING_DELIMITER),
                field: "columnGroupLabel",
                children: columnHeaders,
                drillItems: [],
            },
        ]
        : columnHeaders;
    var rowHeaders = 
    // There are supposed to be only attribute headers on the first dimension
    agGridHeaders_1.getRowHeaders(dimensions[0].headers, columnDefOptions, makeRowGroups);
    // build sortingMap from resultSpec.sorts
    var sorting = resultSpec.sorts || [];
    var sortingMap = {};
    var _d = agGridHeaders_1.assortDimensionHeaders(dimensions), attributeHeaders = _d.attributeHeaders, measureHeaderItems = _d.measureHeaderItems;
    sorting.forEach(function (sortItem) {
        if (typings_1.AFM.isAttributeSortItem(sortItem)) {
            var _a = agGridSorting_1.getAttributeSortItemFieldAndDirection(sortItem, attributeHeaders), field = _a[0], direction = _a[1];
            sortingMap[field] = direction;
        }
        if (typings_1.AFM.isMeasureSortItem(sortItem)) {
            var _b = agGridSorting_1.getMeasureSortItemFieldAndDirection(sortItem, measureHeaderItems), field = _b[0], direction = _b[1];
            sortingMap[field] = direction;
        }
    });
    // assign sorting and indexes
    var columnDefs = rowHeaders.concat(groupColumnHeaders).map(function (column, index) {
        if (column.children) {
            agGridUtils_1.getTreeLeaves(column).forEach(function (leafColumn, leafColumnIndex) {
                leafColumn.index = index + leafColumnIndex;
                agGridSorting_1.assignSorting(leafColumn, sortingMap);
            });
        }
        column.index = index;
        agGridSorting_1.assignSorting(column, sortingMap);
        return column;
    });
    // Add loading indicator to the first column
    if (addLoadingRenderer) {
        var leafColumnDefs = agGridUtils_1.getTreeLeaves(columnDefs);
        if (leafColumnDefs[0]) {
            leafColumnDefs[0].cellRenderer = addLoadingRenderer;
        }
    }
    var columnFields = agGridHeaders_1.getFields(headerItems[1]);
    var rowFields = rowHeaders.map(function (header) { return header.field; });
    // PivotTable execution should always return a two-dimensional array (Execution.DataValue[][])
    var minimalRowData = agGridHeaders_1.getMinimalRowData(data, headerItems[0]);
    var subtotalStyles = agGridUtils_1.getSubtotalStyles(resultSpec.dimensions ? resultSpec.dimensions[0] : null);
    var rowData = minimalRowData.map(function (dataRow, dataRowIndex) {
        return agGridData_1.getRow(dataRow, dataRowIndex, columnFields, rowHeaders, headerItems[0], subtotalStyles, intl);
    });
    var columnKeys = rowFields.concat(columnFields);
    var rowTotals = agGridData_1.getRowTotals(totals, columnKeys, dimensions[0].headers, resultSpec, measureHeaderItems.map(function (mhi) { return mhi.measureHeaderItem.localIdentifier; }), intl);
    return {
        columnDefs: columnDefs,
        rowData: rowData,
        rowTotals: rowTotals,
    };
};
var GdToAgGridAdapter = /** @class */ (function () {
    function GdToAgGridAdapter(resultSpec, getPage, getExecution, onSuccess, getGridApi, intl, columnTotals, getGroupingProvider, cancelPagePromises) {
        this.destroyed = false;
        this.onDestroy = cancelPagePromises;
        this.getRowsImpl = exports.getDataSourceRowsGetter(resultSpec, agGridDataSourceUtils_1.wrapGetPageWithCaching(getPage), getExecution, onSuccess, getGridApi, intl, columnTotals, getGroupingProvider);
    }
    GdToAgGridAdapter.prototype.getRows = function (params) {
        if (this.destroyed) {
            return;
        }
        // NOTE: some of our tests rely on getRows() to return the actual promise
        return this.getRowsImpl(params);
    };
    GdToAgGridAdapter.prototype.destroy = function () {
        this.destroyed = true;
        this.onDestroy();
    };
    return GdToAgGridAdapter;
}());
/**
 * Factory function to create ag-grid data source backed by GoodData executeAFM.
 *
 * @param resultSpec
 * @param getPage
 * @param getExecution
 * @param onSuccess
 * @param getGridApi
 * @param intl
 * @param columnTotals
 * @param getGroupingProvider
 * @param cancelPagePromises
 */
exports.createAgGridDataSource = function (resultSpec, getPage, getExecution, onSuccess, getGridApi, intl, columnTotals, getGroupingProvider, cancelPagePromises) {
    return new GdToAgGridAdapter(resultSpec, getPage, getExecution, onSuccess, getGridApi, intl, columnTotals, getGroupingProvider, cancelPagePromises);
};
//# sourceMappingURL=agGridDataSource.js.map
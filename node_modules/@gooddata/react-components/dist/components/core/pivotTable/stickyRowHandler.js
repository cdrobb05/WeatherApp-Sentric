"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var agGridUtils_1 = require("./agGridUtils");
var agGridApiWrapper_1 = require("./agGridApiWrapper");
var domUtils_1 = require("../../../helpers/domUtils");
exports.initializeStickyRow = function (gridApi) {
    gridApi.setPinnedTopRowData([{}]);
};
exports.updateStickyRowPosition = function (gridApi, apiWrapper) {
    if (apiWrapper === void 0) { apiWrapper = agGridApiWrapper_1.default; }
    var headerHeight = apiWrapper.getHeaderHeight(gridApi);
    apiWrapper.setPinnedTopRowStyle(gridApi, "top", headerHeight + "px");
    apiWrapper.setPinnedTopRowStyle(gridApi, "padding-right", domUtils_1.getScrollbarWidth() + "px");
};
function stickyRowExists(gridApi, apiWrapper) {
    if (apiWrapper === void 0) { apiWrapper = agGridApiWrapper_1.default; }
    return !!apiWrapper.getPinnedTopRowElement(gridApi);
}
exports.stickyRowExists = stickyRowExists;
function shouldUpdate(currentScrollPosition, lastScrollPosition, rowHeight) {
    var initialUpdate = currentScrollPosition.top === 0;
    var currentRowIndex = agGridUtils_1.getGridIndex(currentScrollPosition.top, rowHeight);
    var lastRowIndex = agGridUtils_1.getGridIndex(lastScrollPosition.top, rowHeight);
    var differentRow = currentRowIndex !== lastRowIndex;
    // when scrolling horizontally update with the same cadence as rows as we don't know where the column borders are
    var horizontalBreakpointDistance = rowHeight;
    var currentHorizontalBreakpoint = agGridUtils_1.getGridIndex(currentScrollPosition.left, horizontalBreakpointDistance);
    var lastHorizontalBreakpoint = agGridUtils_1.getGridIndex(lastScrollPosition.left, horizontalBreakpointDistance);
    var differentHorizontalBreakpoint = currentHorizontalBreakpoint !== lastHorizontalBreakpoint;
    return initialUpdate || differentRow || differentHorizontalBreakpoint;
}
exports.updateStickyRowContentClasses = function (currentScrollPosition, lastScrollPosition, rowHeight, gridApi, groupingProvider, apiWrapper) {
    if (!shouldUpdate(currentScrollPosition, lastScrollPosition, rowHeight)) {
        return;
    }
    var firstVisibleRowIndex = agGridUtils_1.getGridIndex(currentScrollPosition.top, rowHeight);
    var firstVisibleRow = gridApi.getDisplayedRowAtIndex(firstVisibleRowIndex);
    var firstVisibleNodeData = firstVisibleRow && firstVisibleRow.data ? firstVisibleRow.data : null;
    if (firstVisibleNodeData === null) {
        apiWrapper.removePinnedTopRowClass(gridApi, "gd-visible-sticky-row");
        return;
    }
    apiWrapper.addPinnedTopRowClass(gridApi, "gd-visible-sticky-row");
    var lastRowIndex = agGridUtils_1.getGridIndex(lastScrollPosition.top, rowHeight);
    var attributeKeys = Object.keys(firstVisibleNodeData).filter(agGridUtils_1.colIdIsSimpleAttribute);
    attributeKeys.forEach(function (columnId) {
        apiWrapper.removeCellClass(gridApi, columnId, lastRowIndex, "gd-cell-show-hidden");
        // the following value is the same as the current one
        if (groupingProvider.isRepeatedValue(columnId, firstVisibleRowIndex + 1)) {
            // set the sticky header text
            apiWrapper.setPinnedTopRowCellText(gridApi, columnId, firstVisibleNodeData[columnId]);
            // show the sticky header
            apiWrapper.removePinnedTopRowCellClass(gridApi, columnId, "gd-hidden-sticky-column");
        }
        else {
            // hide the sticky header
            apiWrapper.addPinnedTopRowCellClass(gridApi, columnId, "gd-hidden-sticky-column");
            // if the column has some groups
            if (groupingProvider.isColumnWithGrouping(columnId)) {
                // show the last cell of the group temporarily so it scrolls out of the viewport nicely
                var currentRowIndex = agGridUtils_1.getGridIndex(currentScrollPosition.top, rowHeight);
                apiWrapper.addCellClass(gridApi, columnId, currentRowIndex, "gd-cell-show-hidden");
            }
        }
    });
};
//# sourceMappingURL=stickyRowHandler.js.map
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2020 GoodData Corporation
var React = require("react");
var FluidLegend_1 = require("../../../visualizations/chart/legend/FluidLegend");
var StaticLegend_1 = require("../../../visualizations/chart/legend/StaticLegend");
var PositionTypes_1 = require("../../../visualizations/chart/legend/PositionTypes");
var common_1 = require("../../../../helpers/geoChart/common");
exports.HEIGHT_OF_SIZE_LEGEND = 161;
var PUSHPIN_TYPE = "pushpin";
function PushpinCategoryLegend(props) {
    var contentRect = props.contentRect, hasSizeLegend = props.hasSizeLegend, responsive = props.responsive, showFluidLegend = props.showFluidLegend;
    var isFluidLegend = common_1.isFluidLegendEnabled(responsive, showFluidLegend);
    return (React.createElement("div", { className: "s-geo-category-legend" }, isFluidLegend
        ? renderFluidCategoryLegend(props, contentRect)
        : renderStaticCategoryLegend(props, contentRect, hasSizeLegend)));
}
exports.default = PushpinCategoryLegend;
function renderFluidCategoryLegend(props, contentRect) {
    var categoryItems = props.categoryItems, _a = props.chartType, chartType = _a === void 0 ? PUSHPIN_TYPE : _a, onItemClick = props.onItemClick;
    var legendProps = {
        chartType: chartType,
        series: categoryItems,
        onItemClick: onItemClick,
    };
    var contentRectClient = contentRect.client;
    var usedWidth = contentRectClient && contentRectClient.width ? Math.floor(contentRectClient.width) : 0;
    return React.createElement(FluidLegend_1.default, __assign({}, legendProps, { containerWidth: usedWidth }));
}
function renderStaticCategoryLegend(props, contentRect, hasSizeLegend) {
    var categoryItems = props.categoryItems, _a = props.chartType, chartType = _a === void 0 ? PUSHPIN_TYPE : _a, position = props.position, height = props.height, format = props.format, locale = props.locale, onItemClick = props.onItemClick, responsive = props.responsive;
    // For Geo Pushpin with position left/right
    // we set the height of series to number of actual displayed items
    // so that, size legend will be visible
    var shouldFillAvailableSpace = position !== PositionTypes_1.LEFT && position !== PositionTypes_1.RIGHT;
    var legendProps = {
        chartType: chartType,
        format: format,
        locale: locale,
        position: position,
        responsive: responsive,
        series: categoryItems,
        shouldFillAvailableSpace: shouldFillAvailableSpace,
        onItemClick: onItemClick,
    };
    var contentRectClient = contentRect.client;
    var hasSizeAndLeftRightPosition = hasSizeLegend && (position === PositionTypes_1.LEFT || position === PositionTypes_1.RIGHT);
    var measuredHeight = contentRectClient && contentRectClient.height ? Math.floor(contentRectClient.height) : 0;
    var usedHeight = (height || measuredHeight) - (hasSizeAndLeftRightPosition ? exports.HEIGHT_OF_SIZE_LEGEND : 0);
    return React.createElement(StaticLegend_1.default, __assign({}, legendProps, { containerHeight: usedHeight }));
}
//# sourceMappingURL=PushpinCategoryLegend.js.map
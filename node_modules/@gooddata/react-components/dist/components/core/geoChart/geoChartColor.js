"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2020 GoodData Corporation
var range = require("lodash/range");
var isEmpty = require("lodash/isEmpty");
var isFinite = require("lodash/isFinite");
var color_1 = require("../../visualizations/utils/color");
var geoChart_1 = require("../../../constants/geoChart");
var utils_1 = require("../../../helpers/utils");
var MappingHeader_1 = require("../../../interfaces/MappingHeader");
var DEFAULT_SEGMENT_ITEM = "default_segment_item";
var DEFAULT_COLOR_INDEX_IN_PALETTE = geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE - 1;
function getColorIndexInPalette(value, min, max) {
    if (!isFinite(value) || min === max || value === min) {
        return 0;
    }
    if (value === max) {
        return DEFAULT_COLOR_INDEX_IN_PALETTE;
    }
    var step = (max - min) / geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE;
    for (var i = 0, offset = min; i < geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE; i++, offset += step) {
        if (offset >= value) {
            return i;
        }
    }
    return DEFAULT_COLOR_INDEX_IN_PALETTE;
}
exports.getColorIndexInPalette = getColorIndexInPalette;
function getColorPaletteMapping(colorStrategy) {
    var colorAssignment = colorStrategy.getColorAssignment();
    return colorAssignment.reduce(function (result, item, index) {
        var _a, _b;
        var color = colorStrategy.getColorByIndex(index);
        var colorPalette = color_1.getColorPalette(color, geoChart_1.DEFAULT_PUSHPIN_COLOR_OPACITY);
        // color base on Location
        if (MappingHeader_1.isMappingHeaderAttribute(item.headerItem)) {
            return _a = {},
                _a[DEFAULT_SEGMENT_ITEM] = colorPalette,
                _a;
        }
        // color base on SegmentBy
        var name = MappingHeader_1.isMappingHeaderAttributeItem(item.headerItem)
            ? item.headerItem.attributeHeaderItem.name
            : DEFAULT_SEGMENT_ITEM;
        return __assign({}, result, (_b = {}, _b[name] = colorPalette, _b));
    }, {});
}
exports.getColorPaletteMapping = getColorPaletteMapping;
/**
 * Return RGB border and background colors base on color and segment values
 *  Example:
 *      [any-number] => [{
 *           border: "rgb(127,224,198)",
 *           background: "rgb(215,242,250)",
 *      }]
 * @param colorValues
 * @param segmentValues
 */
function getPushpinColors(colorValues, segmentValues, colorStrategy) {
    if (segmentValues === void 0) { segmentValues = []; }
    var defaultColorValue = colorStrategy.getColorByIndex(0);
    var defaultColor = color_1.rgbToRgba(defaultColorValue, geoChart_1.DEFAULT_PUSHPIN_COLOR_OPACITY);
    if (!colorValues.length && !segmentValues.length) {
        return [
            {
                border: geoChart_1.DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: defaultColor,
            },
        ];
    }
    var segmentNames = segmentValues.map(function (value) { return value; });
    var colorPaletteMapping = getColorPaletteMapping(colorStrategy);
    if (!colorValues.length) {
        return segmentNames.map(function (name) {
            var palette = colorPaletteMapping[name];
            return {
                border: geoChart_1.DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: palette[DEFAULT_COLOR_INDEX_IN_PALETTE],
            };
        });
    }
    var colorsWithoutNull = colorValues.filter(isFinite);
    var _a = utils_1.getMinMax(colorsWithoutNull), min = _a.min, max = _a.max;
    if (min === max && !segmentValues.length) {
        return [
            {
                border: geoChart_1.DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: defaultColor,
            },
        ];
    }
    return colorValues.map(function (color, index) {
        var value = isFinite(color) ? color : min;
        var colorIndex = getColorIndexInPalette(value, min, max);
        var segmentItemName = segmentNames[index] || DEFAULT_SEGMENT_ITEM;
        var palette = colorPaletteMapping[segmentItemName];
        return {
            border: palette[DEFAULT_COLOR_INDEX_IN_PALETTE],
            background: palette[colorIndex],
        };
    });
}
exports.getPushpinColors = getPushpinColors;
function generateLegendColorData(colorSeries, colorString) {
    if (isEmpty(colorSeries)) {
        return [];
    }
    var colorPalette = color_1.getColorPalette(colorString, geoChart_1.DEFAULT_PUSHPIN_COLOR_OPACITY);
    var min = Math.min.apply(Math, colorSeries);
    var max = Math.max.apply(Math, colorSeries);
    var offset = (max - min) / geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE;
    if (min === max) {
        return [];
    }
    return range(0, geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE).map(function (index) {
        var from = min + offset * index;
        var isLastItem = index === geoChart_1.DEFAULT_PUSHPIN_COLOR_SCALE - 1;
        var to = isLastItem ? max : from + offset;
        var range = {
            from: from,
            to: to,
        };
        return {
            range: range,
            color: colorPalette[index],
        };
    });
}
exports.generateLegendColorData = generateLegendColorData;
//# sourceMappingURL=geoChartColor.js.map
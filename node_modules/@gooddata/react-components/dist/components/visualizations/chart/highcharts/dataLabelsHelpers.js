"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2019 GoodData Corporation
var flatMap = require("lodash/flatMap");
var get = require("lodash/get");
var helpers_1 = require("./helpers");
var common_1 = require("../../utils/common");
var label_1 = require("../../../../constants/label");
function isLabelOverlappingItsShape(point) {
    var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs;
    if (dataLabel && shapeArgs) {
        // shapeArgs for point hidden by legend is undefined
        if (shapeArgs.width === undefined) {
            return dataLabel.width > shapeArgs.r * 2 || dataLabel.height > shapeArgs.r * 2;
        }
        return dataLabel.width > shapeArgs.width || dataLabel.height > shapeArgs.height;
    }
    return false;
}
exports.isLabelOverlappingItsShape = isLabelOverlappingItsShape;
exports.getDataLabelsGdcVisible = function (chart) {
    return get(chart, "options.plotOptions.gdcOptions.dataLabels.visible", "auto");
};
var isLabelsStackedFromYAxis = function (chart) {
    return get(chart, "userOptions.yAxis.0.stackLabels.enabled", false) ||
        get(chart, "userOptions.yAxis.1.stackLabels.enabled", false);
};
exports.areLabelsStacked = function (chart) { return isLabelsStackedFromYAxis(chart) && helpers_1.isStacked(chart); };
exports.hasDataLabel = function (point) { return point.dataLabel; };
exports.hasShape = function (point) { return point.shapeArgs; };
exports.hasLabelInside = function (point) {
    var verticalAlign = get(point, "dataLabel.alignOptions.verticalAlign", "");
    return verticalAlign === "middle";
};
exports.minimizeDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.width = 0;
        dataLabel.height = 0;
    }
};
exports.hideDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.hide();
    }
};
exports.showDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.show();
    }
};
exports.hideDataLabels = function (points) {
    points.filter(exports.hasDataLabel).forEach(exports.hideDataLabel);
};
exports.showDataLabels = function (points) {
    points.filter(exports.hasDataLabel).forEach(exports.showDataLabel);
};
function showDataLabelInAxisRange(point, value, axisRangeForAxes) {
    var isSecondAxis = get(point, "series.yAxis.opposite", false);
    var axisRange = axisRangeForAxes[isSecondAxis ? "second" : "first"];
    var isInsideAxisRange = helpers_1.pointInRange(value, axisRange);
    if (!isInsideAxisRange) {
        exports.hideDataLabel(point);
    }
}
exports.showDataLabelInAxisRange = showDataLabelInAxisRange;
function showStackLabelInAxisRange(point, axisRangeForAxes) {
    var isSecondAxis = get(point, "series.yAxis.opposite", false);
    var axisRange = axisRangeForAxes[isSecondAxis ? "second" : "first"];
    var end = point.stackY || point.total;
    var start = end - point.y;
    var isWholeUnderMin = start <= axisRange.minAxisValue && end <= axisRange.minAxisValue;
    var isWholeAboveMax = start >= axisRange.maxAxisValue && end >= axisRange.maxAxisValue;
    if (isWholeUnderMin || isWholeAboveMax) {
        exports.hideDataLabel(point);
    }
}
exports.showStackLabelInAxisRange = showStackLabelInAxisRange;
exports.hideAllLabels = function (_a) {
    var series = _a.series;
    return exports.hideDataLabels(flatMap(series, function (s) { return s.points; }));
};
exports.showAllLabels = function (_a) {
    var series = _a.series;
    return exports.showDataLabels(flatMap(series, function (s) { return s.points; }));
};
function getDataLabelAttributes(point) {
    var dataLabel = get(point, "dataLabel", null);
    var parentGroup = get(point, "dataLabel.parentGroup", null);
    var labelSafeOffset = -100; // labels outside axis range have typically -9999, hide them
    var labelVisible = dataLabel && dataLabel.x > labelSafeOffset && dataLabel.y > labelSafeOffset;
    if (dataLabel && parentGroup && labelVisible) {
        return {
            x: dataLabel.x + parentGroup.translateX,
            y: dataLabel.y + parentGroup.translateY,
            width: dataLabel.width,
            height: dataLabel.height,
        };
    }
    return {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    };
}
exports.getDataLabelAttributes = getDataLabelAttributes;
function intersectsParentLabel(point, points) {
    var pointParent = parseInt(point.parent, 10);
    // Highchart 7 doesn't render dataLabel at points which have null value
    var pointLabelShape = point.dataLabel;
    if (isNaN(pointParent) || !pointLabelShape) {
        return false;
    }
    var parentPoint = points[pointParent];
    var parentLabelShape = parentPoint.dataLabel;
    return helpers_1.isIntersecting(pointLabelShape, parentLabelShape);
}
exports.intersectsParentLabel = intersectsParentLabel;
function isTruncatedByMin(shape, chart) {
    return shape.y + shape.height > chart.clipBox.height;
}
function isTruncatedByMax(shape) {
    return shape.y < 0;
}
// works for both column/bar chart thanks bar's 90deg rotation
function getShapeVisiblePart(shape, chart, wholeSize) {
    if (isTruncatedByMax(shape)) {
        return shape.y + shape.height;
    }
    else if (isTruncatedByMin(shape, chart)) {
        return chart.clipBox.height - shape.y;
    }
    return wholeSize;
}
exports.getShapeVisiblePart = getShapeVisiblePart;
function getLabelStyle(type, stacking) {
    if (common_1.isAreaChart(type)) {
        return label_1.BLACK_LABEL;
    }
    return stacking || common_1.isOneOfTypes(type, label_1.whiteDataLabelTypes) ? label_1.WHITE_LABEL : label_1.BLACK_LABEL;
}
exports.getLabelStyle = getLabelStyle;
/**
 * A callback function to format data label and `this` is required by Highchart
 * Ref: https://api.highcharts.com/highcharts/yAxis.labels.formatter
 */
function formatAsPercent(unit) {
    if (unit === void 0) { unit = 100; }
    var val = parseFloat((this.value * unit).toPrecision(14));
    return val + "%";
}
exports.formatAsPercent = formatAsPercent;
function isInPercent(format) {
    if (format === void 0) { format = ""; }
    return format.includes("%");
}
exports.isInPercent = isInPercent;
function getLabelsVisibilityConfig(visible) {
    switch (visible) {
        case "auto":
            return {
                enabled: true,
                allowOverlap: false,
            };
        case true:
            return {
                enabled: true,
                allowOverlap: true,
            };
        case false:
            return {
                enabled: false,
            };
        default:
            // keep decision on each chart for `undefined`
            return {};
    }
}
exports.getLabelsVisibilityConfig = getLabelsVisibilityConfig;
//# sourceMappingURL=dataLabelsHelpers.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2018 GoodData Corporation
var sortBy = require("lodash/sortBy");
var helpers_1 = require("../../helpers");
var dataLabelsHelpers_1 = require("../../dataLabelsHelpers");
var toggleStackedChartLabels = function (visiblePoints, axisRangeForAxes) {
    var intersectionFound = visiblePoints.filter(dataLabelsHelpers_1.hasDataLabel).some(function (point) {
        var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs;
        if (dataLabel && shapeArgs) {
            var dataLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(point);
            var shapeAttr = helpers_1.getShapeAttributes(point);
            return dataLabelAttr.height + 2 * dataLabel.padding > shapeAttr.height;
        }
        return false;
    });
    if (intersectionFound) {
        dataLabelsHelpers_1.hideDataLabels(visiblePoints);
    }
    else {
        visiblePoints.filter(dataLabelsHelpers_1.hasDataLabel).forEach(function (point) {
            var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs, chart = point.series.chart;
            if (dataLabel && shapeArgs) {
                var dataLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(point);
                var shapeAttr = helpers_1.getShapeAttributes(point);
                var labelWidth = dataLabelAttr.width + 2 * dataLabel.padding;
                var shapeWidth = dataLabelsHelpers_1.getShapeVisiblePart(shapeArgs, chart, shapeAttr.width);
                var foundIntersection = labelWidth > shapeWidth;
                // switch axis for bar chart
                return foundIntersection
                    ? dataLabelsHelpers_1.hideDataLabel(point)
                    : dataLabelsHelpers_1.showStackLabelInAxisRange(point, axisRangeForAxes);
            }
            return null;
        });
    }
};
var toggleNonStackedChartLabels = function (points, axisRangeForAxes, shouldCheckShapeIntersection) {
    if (shouldCheckShapeIntersection === void 0) { shouldCheckShapeIntersection = false; }
    var sortedPoints = sortBy(points, function (a, b) {
        var firstLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(a);
        var nextLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(b);
        return firstLabelAttr.y - nextLabelAttr.y;
    });
    var neighbors = helpers_1.toNeighbors(sortedPoints);
    var intersectionFound = neighbors.some(function (_a) {
        var firstPoint = _a[0], nextPoint = _a[1];
        var firstDataLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(firstPoint);
        var nextDataLabelAttr = dataLabelsHelpers_1.getDataLabelAttributes(nextPoint);
        if (shouldCheckShapeIntersection) {
            var firstShapeAttr = helpers_1.getShapeAttributes(firstPoint);
            var nextShapeAttr = helpers_1.getShapeAttributes(nextPoint);
            return (helpers_1.isIntersecting(firstDataLabelAttr, nextDataLabelAttr) ||
                helpers_1.isIntersecting(firstDataLabelAttr, nextShapeAttr) ||
                helpers_1.isIntersecting(firstShapeAttr, nextDataLabelAttr));
        }
        return helpers_1.isIntersecting(firstDataLabelAttr, nextDataLabelAttr);
    });
    if (intersectionFound) {
        dataLabelsHelpers_1.hideDataLabels(points);
    }
    else {
        points.forEach(function (point) { return dataLabelsHelpers_1.showDataLabelInAxisRange(point, point.y, axisRangeForAxes); });
    }
};
exports.autohideBarLabels = function (chart) {
    var isStackedChart = helpers_1.isStacked(chart);
    var visiblePoints = helpers_1.getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = helpers_1.getAxisRangeForAxes(chart);
    if (isStackedChart) {
        toggleStackedChartLabels(visiblePoints, axisRangeForAxes);
    }
    else {
        toggleNonStackedChartLabels(visiblePoints, axisRangeForAxes, true);
    }
};
exports.handleBarLabelsOutsideChart = function (chart) {
    var visiblePoints = helpers_1.getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = helpers_1.getAxisRangeForAxes(chart);
    visiblePoints.forEach(function (point) {
        if (!helpers_1.isStacked(chart)) {
            dataLabelsHelpers_1.showDataLabelInAxisRange(point, point.y, axisRangeForAxes);
        }
        else {
            // fix for HCH bug for negative stack labels
            dataLabelsHelpers_1.showStackLabelInAxisRange(point, axisRangeForAxes);
        }
    });
};
//# sourceMappingURL=autohideBarLabels.js.map
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var flatten = require("lodash/flatten");
var get = require("lodash/get");
var pick = require("lodash/pick");
var map = require("lodash/map");
var zip = require("lodash/zip");
var unzip = require("lodash/unzip");
var initial = require("lodash/initial");
var tail = require("lodash/tail");
var isEmpty = require("lodash/isEmpty");
var maxBy = require("lodash/maxBy");
var minBy = require("lodash/minBy");
var min = require("lodash/min");
var max = require("lodash/max");
var isNil = require("lodash/isNil");
var visualizationTypes_1 = require("../../../../constants/visualizationTypes");
var common_1 = require("../../utils/common");
var alignments_1 = require("../../../../constants/alignments");
// https://silentmatt.com/rectangle-intersection/
exports.rectanglesAreOverlapping = function (r1, r2, padding) {
    if (padding === void 0) { padding = 0; }
    return r1.left - padding < r2.right + padding &&
        r1.right + padding > r2.left - padding &&
        r1.top - padding < r2.bottom + padding &&
        r1.bottom + padding > r2.top - padding;
};
exports.isIntersecting = function (r1, r2) {
    return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
};
exports.toNeighbors = function (array) { return zip(initial(array), tail(array)); };
exports.getVisibleSeries = function (chart) { return chart.series && chart.series.filter(function (s) { return s.visible; }); };
exports.getHiddenSeries = function (chart) { return chart.series && chart.series.filter(function (s) { return !s.visible; }); };
exports.getDataPoints = function (series) { return flatten(unzip(map(series, function (s) { return s.points; }))); };
exports.getDataPointsOfVisibleSeries = function (chart) { return exports.getDataPoints(exports.getVisibleSeries(chart)); };
exports.getChartType = function (chart) { return get(chart, "options.chart.type"); };
exports.isStacked = function (chart) {
    var chartType = exports.getChartType(chart);
    if (get(chart, "userOptions.plotOptions." + chartType + ".stacking", false) &&
        chart.axes.some(function (axis) { return !isEmpty(axis.stacks); })) {
        return true;
    }
    if (get(chart, "userOptions.plotOptions.series.stacking", false) &&
        chart.axes.some(function (axis) { return !isEmpty(axis.stacks); })) {
        return true;
    }
    return false;
};
function getChartProperties(config, type) {
    var isInvertedChart = common_1.isInvertedChartType(type);
    var chartProps = {
        xAxisProps: isInvertedChart ? __assign({}, config.yaxis) : __assign({}, config.xaxis),
        yAxisProps: isInvertedChart ? __assign({}, config.xaxis) : __assign({}, config.yaxis),
    };
    var secondaryXAxisProps = isInvertedChart
        ? __assign({}, config.secondary_yaxis) : __assign({}, config.secondary_xaxis);
    var secondaryYAxisProps = isInvertedChart
        ? __assign({}, config.secondary_xaxis) : __assign({}, config.secondary_yaxis);
    if (!isEmpty(secondaryXAxisProps)) {
        chartProps.secondary_xAxisProps = secondaryXAxisProps;
    }
    if (!isEmpty(secondaryYAxisProps)) {
        chartProps.secondary_yAxisProps = secondaryYAxisProps;
    }
    return chartProps;
}
exports.getChartProperties = getChartProperties;
exports.getPointPositions = function (point) {
    var dataLabel = point.dataLabel, graphic = point.graphic;
    var labelRect = dataLabel.element.getBoundingClientRect();
    var shapeRect = graphic.element.getBoundingClientRect();
    return {
        shape: shapeRect,
        label: labelRect,
        labelPadding: dataLabel.padding,
        show: function () { return dataLabel.show(); },
        hide: function () { return dataLabel.hide(); },
    };
};
function getShapeAttributes(point) {
    var series = point.series, shapeArgs = point.shapeArgs;
    var _a = series.chart, plotSizeX = _a.plotSizeX, plotSizeY = _a.plotSizeY, options = _a.options;
    if (options.chart.type === visualizationTypes_1.VisualizationTypes.BAR) {
        return {
            x: Math.floor(plotSizeY - (shapeArgs.y - series.group.translateX) - shapeArgs.height),
            y: Math.ceil(plotSizeX + series.group.translateY - shapeArgs.x - shapeArgs.width),
            width: shapeArgs.height,
            height: shapeArgs.width,
        };
    }
    else if (options.chart.type === visualizationTypes_1.VisualizationTypes.COLUMN) {
        return {
            x: shapeArgs.x + series.group.translateX,
            y: shapeArgs.y + series.group.translateY,
            width: shapeArgs.width,
            height: shapeArgs.height,
        };
    }
    return {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    };
}
exports.getShapeAttributes = getShapeAttributes;
function getExtremeOnAxis(min, max) {
    var axisMin = min >= 0 ? 0 : min;
    var axisMax = max < 0 ? 0 : max;
    return { axisMin: axisMin, axisMax: axisMax };
}
function shouldFollowPointerForDualAxes(chartOptions) {
    var yAxes = get(chartOptions, "yAxes", []);
    if (yAxes.length <= 1) {
        return false;
    }
    var hasMinMaxValue = [
        "yAxisProps.min",
        "yAxisProps.max",
        "secondary_yAxisProps.min",
        "secondary_yAxisProps.max",
    ].reduce(function (result, key) {
        var value = get(chartOptions, key, undefined);
        return isEmpty(value) ? result : value;
    }, undefined);
    return yAxes.length > 1 && hasMinMaxValue;
}
exports.shouldFollowPointerForDualAxes = shouldFollowPointerForDualAxes;
function isMinMaxLimitData(chartOptions, key) {
    var yMin = parseFloat(get(chartOptions, key + ".min", ""));
    var yMax = parseFloat(get(chartOptions, key + ".max", ""));
    if (isNaN(yMin) && isNaN(yMax)) {
        return false;
    }
    var _a = getDataExtremeDataValues(chartOptions), minDataValue = _a.minDataValue, maxDataValue = _a.maxDataValue;
    var _b = getExtremeOnAxis(minDataValue, maxDataValue), axisMin = _b.axisMin, axisMax = _b.axisMax;
    return (!isNaN(yMax) && axisMax > yMax) || (!isNaN(yMin) && axisMin < yMin);
}
function shouldFollowPointer(chartOptions) {
    if (shouldFollowPointerForDualAxes(chartOptions)) {
        return true;
    }
    return (isMinMaxLimitData(chartOptions, "yAxisProps") ||
        isMinMaxLimitData(chartOptions, "secondary_yAxisProps"));
}
exports.shouldFollowPointer = shouldFollowPointer;
function isSerieVisible(serie) {
    return serie.visible === undefined || serie.visible;
}
function getNonStackedMaxValue(series) {
    return series.reduce(function (maxValue, serie) {
        if (isSerieVisible(serie)) {
            var maxSerieValue = getSerieMaxDataValue(serie.data);
            return maxValue > maxSerieValue ? maxValue : maxSerieValue;
        }
        return maxValue;
    }, Number.MIN_SAFE_INTEGER);
}
function getNonStackedMinValue(series) {
    return series.reduce(function (minValue, serie) {
        if (isSerieVisible(serie)) {
            var minSerieValue = getSerieMinDataValue(serie.data);
            return minValue < minSerieValue ? minValue : minSerieValue;
        }
        return minValue;
    }, Number.MAX_SAFE_INTEGER);
}
function getDataExtremeDataValues(chartOptions) {
    var series = get(chartOptions, "data.series");
    var maxDataValue = chartOptions.hasStackByAttribute
        ? getStackedMaxValue(series)
        : getNonStackedMaxValue(series);
    var minDataValue = chartOptions.hasStackByAttribute
        ? getStackedMinValue(series)
        : getNonStackedMinValue(series);
    return { minDataValue: minDataValue, maxDataValue: maxDataValue };
}
function getSerieMaxDataValue(serieData) {
    var max = maxBy(serieData, function (item) { return (item && item.y ? item.y : null); });
    return max ? max.y : Number.MIN_SAFE_INTEGER;
}
function getSerieMinDataValue(serieData) {
    var min = minBy(serieData, function (item) { return (item && item.y ? item.y : null); });
    return min ? min.y : Number.MAX_SAFE_INTEGER;
}
function getStackedMaxValue(series) {
    var maximumPerColumn = getColumnExtremeValue(series, getMaxFromPositiveNegativeStacks);
    var maxValue = max(maximumPerColumn);
    return !isNil(maxValue) ? maxValue : Number.MIN_SAFE_INTEGER;
}
exports.getStackedMaxValue = getStackedMaxValue;
function getStackedMinValue(series) {
    var minimumPerColumn = getColumnExtremeValue(series, getMinFromPositiveNegativeStacks);
    var minValue = min(minimumPerColumn);
    return !isNil(minValue) ? minValue : Number.MAX_SAFE_INTEGER;
}
exports.getStackedMinValue = getStackedMinValue;
function getColumnExtremeValue(series, extremeColumnGetter) {
    var seriesDataPerColumn = zip.apply(void 0, series.filter(isSerieVisible).map(function (serie) { return serie.data; }));
    var seriesDataYValue = seriesDataPerColumn.map(function (data) { return data.map(function (x) { return x.y; }); });
    return seriesDataYValue.map(extremeColumnGetter);
}
function getMaxFromPositiveNegativeStacks(data) {
    return data.reduce(function (acc, current) {
        if (isNil(current)) {
            return acc;
        }
        if (current < 0 || acc < 0) {
            return Math.max(acc, current);
        }
        return acc + current;
    }, Number.MIN_SAFE_INTEGER);
}
function getMinFromPositiveNegativeStacks(data) {
    return data.reduce(function (acc, current) {
        if (isNil(current)) {
            return acc;
        }
        if (current > 0 || acc > 0) {
            return Math.min(acc, current);
        }
        return acc + current;
    }, Number.MAX_SAFE_INTEGER);
}
function shouldStartOnTick(chartOptions, axisPropsKey) {
    if (axisPropsKey === void 0) { axisPropsKey = "yAxisProps"; }
    var min = parseFloat(get(chartOptions, axisPropsKey + ".min", ""));
    var max = parseFloat(get(chartOptions, axisPropsKey + ".max", ""));
    if (isNaN(min) && isNaN(max)) {
        return true;
    }
    if (!isNaN(min) && !isNaN(max)) {
        return min > max;
    }
    var series = get(chartOptions, "data.series");
    var minDataValue = chartOptions.hasStackByAttribute
        ? getStackedMinValue(series)
        : getNonStackedMinValue(series);
    var hasIncorrectMax = !isNaN(max) && max <= minDataValue;
    if (hasIncorrectMax) {
        return true;
    }
    return false;
}
exports.shouldStartOnTick = shouldStartOnTick;
function shouldEndOnTick(chartOptions, axisPropsKey) {
    if (axisPropsKey === void 0) { axisPropsKey = "yAxisProps"; }
    var min = parseFloat(get(chartOptions, axisPropsKey + ".min", ""));
    var max = parseFloat(get(chartOptions, axisPropsKey + ".max", ""));
    if (isNaN(min) && isNaN(max)) {
        return true;
    }
    if (!isNaN(min) && !isNaN(max)) {
        return min > max;
    }
    var series = get(chartOptions, "data.series");
    var maxDataValue = chartOptions.hasStackByAttribute
        ? getStackedMaxValue(series)
        : getNonStackedMaxValue(series);
    var hasIncorrectMin = !isNaN(min) && min >= maxDataValue;
    if (hasIncorrectMin) {
        return true;
    }
    return false;
}
exports.shouldEndOnTick = shouldEndOnTick;
function shouldXAxisStartOnTickOnBubbleScatter(chartOptions) {
    var min = parseFloat(get(chartOptions, "xAxisProps.min", ""));
    return isNaN(min) ? true : false;
}
exports.shouldXAxisStartOnTickOnBubbleScatter = shouldXAxisStartOnTickOnBubbleScatter;
function shouldYAxisStartOnTickOnBubbleScatter(chartOptions) {
    var min = parseFloat(get(chartOptions, "yAxisProps.min", ""));
    var series = get(chartOptions, "data.series");
    var maxDataValue = getNonStackedMaxValue(series);
    return isNaN(min) || min > maxDataValue ? true : false;
}
exports.shouldYAxisStartOnTickOnBubbleScatter = shouldYAxisStartOnTickOnBubbleScatter;
function getAxisRangeForAxes(chart) {
    var yAxis = get(chart, "yAxis", []);
    return yAxis
        .map(function (axis) { return pick(axis, ["opposite", "min", "max"]); })
        .map(function (_a) {
        var opposite = _a.opposite, min = _a.min, max = _a.max;
        return ({ axis: opposite ? "second" : "first", min: min, max: max });
    })
        .reduce(function (result, _a) {
        var axis = _a.axis, min = _a.min, max = _a.max;
        result[axis] = {
            minAxisValue: min,
            maxAxisValue: max,
        };
        return result;
    }, {});
}
exports.getAxisRangeForAxes = getAxisRangeForAxes;
function pointInRange(pointValue, axisRange) {
    return axisRange.minAxisValue <= pointValue && pointValue <= axisRange.maxAxisValue;
}
exports.pointInRange = pointInRange;
function alignChart(chart) {
    var container = chart.container;
    if (!container) {
        return;
    }
    var _a = container.getBoundingClientRect(), chartWidth = _a.width, chartHeight = _a.height;
    var margin = chartHeight - chartWidth;
    var isVerticalRectContainer = margin > 0;
    var verticalAlign = get(chart, "userOptions.chart.verticalAlign", alignments_1.MIDDLE);
    var isAlignedToTop = verticalAlign === alignments_1.TOP;
    var isAlignedToBottom = verticalAlign === alignments_1.BOTTOM;
    var type = exports.getChartType(chart);
    var className = "s-highcharts-" + type + "-aligned-to-" + verticalAlign;
    var chartOptions = {};
    if (isVerticalRectContainer && verticalAlign !== alignments_1.MIDDLE) {
        chartOptions = {
            spacingTop: isAlignedToTop ? 0 : undefined,
            spacingBottom: isAlignedToBottom ? 0 : undefined,
            marginTop: isAlignedToBottom ? margin : undefined,
            marginBottom: isAlignedToTop ? margin : undefined,
            className: className,
        };
    }
    else {
        chartOptions = {
            spacingTop: undefined,
            spacingBottom: undefined,
            marginTop: undefined,
            marginBottom: undefined,
            className: className,
        };
    }
    chart.update({
        chart: chartOptions,
    }, false, false, false);
}
exports.alignChart = alignChart;
//# sourceMappingURL=helpers.js.map
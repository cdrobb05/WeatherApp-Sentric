import { AFM, Execution, VisualizationObject } from "@gooddata/typings";
import Highcharts from "./highcharts/highchartsEntryPoint";
import { VisType } from "../../../constants/visualizationTypes";
import { IChartConfig, IChartLimits, ISeriesDataItem, ISeriesItem, IPointData, IChartOptions } from "../../../interfaces/Config";
import { IHeaderPredicate } from "../../../interfaces/HeaderPredicate";
import { IColorStrategy } from "./colorFactory";
import { IUnwrappedAttributeHeaderWithItems } from "../typings/chart";
export declare const supportedDualAxesChartTypes: ("area" | "line" | "column" | "bar" | "bullet" | "combo" | "combo2")[];
export declare const supportedTooltipFollowPointerChartTypes: ("column" | "bar" | "bullet" | "combo" | "combo2")[];
export declare const supportedStackingAttributesChartTypes: ("area" | "column" | "bar" | "bullet" | "combo" | "combo2")[];
export interface IValidationResult {
    dataTooLarge: boolean;
    hasNegativeValue: boolean;
}
export declare type ITooltipFactory = (point: IPointData, maxTooltipContentWidth: number, percentageValue?: number) => string;
export declare function isNegativeValueIncluded(series: ISeriesItem[]): boolean;
export declare function cannotShowNegativeValues(type: string): boolean;
export declare function validateData(limits: IChartLimits, chartOptions: IChartOptions): IValidationResult;
export declare function isDerivedMeasure(measureItem: Execution.IMeasureHeaderItem, afm: AFM.IAfm): boolean;
export declare function findParentMeasureIndex(afm: AFM.IAfm, measureItemIndex: number): number;
export declare function getSeriesItemData(seriesItem: string[], seriesIndex: number, measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], viewByAttribute: IUnwrappedAttributeHeaderWithItems, stackByAttribute: IUnwrappedAttributeHeaderWithItems, type: string, colorStrategy: IColorStrategy): IPointData[];
export declare function getHeatmapSeries(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"]): {
    name: string;
    data: IPointData[];
    turboThreshold: number;
    yAxis: number;
    dataLabels: {
        formatGD: any;
    };
    legendIndex: number;
}[];
export declare function getScatterPlotSeries(executionResultData: Execution.DataValue[][], stackByAttribute: any, mdObject: VisualizationObject.IVisualizationObjectContent, colorStrategy: IColorStrategy): {
    turboThreshold: number;
    color: string;
    legendIndex: number;
    data: ISeriesDataItem[];
}[];
export declare function getBubbleChartSeries(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], stackByAttribute: any, mdObject: VisualizationObject.IVisualizationObjectContent, colorStrategy: IColorStrategy): {
    name: any;
    color: string;
    legendIndex: number;
    data: any;
}[];
export declare function getTreemapStackedSeriesDataWithViewBy(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], viewByAttribute: IUnwrappedAttributeHeaderWithItems, stackByAttribute: IUnwrappedAttributeHeaderWithItems, colorStrategy: IColorStrategy): any[];
export declare function getTreemapStackedSeriesDataWithMeasures(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], stackByAttribute: any, colorStrategy: IColorStrategy): any[];
export declare function getTreemapStackedSeries(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], viewByAttribute: IUnwrappedAttributeHeaderWithItems, stackByAttribute: IUnwrappedAttributeHeaderWithItems, colorStrategy: IColorStrategy): {
    name: string;
    legendType: string;
    showInLegend: boolean;
    data: any[];
    turboThreshold: number;
}[];
export declare function getSeries(executionResultData: Execution.DataValue[][], measureGroup: Execution.IMeasureGroupHeader["measureGroupHeader"], viewByAttribute: IUnwrappedAttributeHeaderWithItems, stackByAttribute: IUnwrappedAttributeHeaderWithItems, type: string, mdObject: VisualizationObject.IVisualizationObjectContent, colorStrategy: IColorStrategy, occupiedMeasureBucketsLocalIdentifiers?: VisualizationObject.Identifier[]): any;
export declare const customEscape: (str: string) => string;
export declare function buildTooltipFactory(viewByAttribute: IUnwrappedAttributeHeaderWithItems, type: string, config?: IChartConfig, isDualAxis?: boolean): ITooltipFactory;
export declare function buildTooltipForTwoAttributesFactory(viewByAttribute: IUnwrappedAttributeHeaderWithItems, viewByParentAttribute: IUnwrappedAttributeHeaderWithItems, config?: IChartConfig, isDualAxis?: boolean): ITooltipFactory;
export declare function generateTooltipXYFn(measures: any, stackByAttribute: IUnwrappedAttributeHeaderWithItems, config?: IChartConfig): ITooltipFactory;
export declare function generateTooltipHeatmapFn(viewByAttribute: any, stackByAttribute: any, config?: IChartConfig): ITooltipFactory;
export declare function buildTooltipTreemapFactory(viewByAttribute: IUnwrappedAttributeHeaderWithItems, stackByAttribute: IUnwrappedAttributeHeaderWithItems, config?: IChartConfig): ITooltipFactory;
export interface ILegacyMeasureHeader {
    uri: string;
    identifier?: string;
    localIdentifier?: string;
    name: string;
    format?: string;
}
export interface ILegacyAttributeHeader extends ILegacyMeasureHeader {
    attribute: any;
}
export declare type ILegacyHeader = ILegacyAttributeHeader | ILegacyMeasureHeader;
export declare function isLegacyAttributeHeader(header: ILegacyHeader): header is ILegacyAttributeHeader;
export declare function getDrillableSeries(series: any, drillableItems: IHeaderPredicate[], viewByAttributes: IUnwrappedAttributeHeaderWithItems[], stackByAttribute: IUnwrappedAttributeHeaderWithItems, executionResponse: Execution.IExecutionResponse, afm: AFM.IAfm, type: VisType): any;
export declare const HEAT_MAP_CATEGORIES_COUNT = 7;
export declare const HIGHCHARTS_PRECISION = 15;
export declare const DEFAULT_HEATMAP_COLOR_INDEX = 1;
export declare function getHeatmapDataClasses(series: any, colorStrategy: IColorStrategy): Highcharts.ColorAxisDataClassesOptions[];
export declare function getDefaultTreemapAttributes(dimensions: Execution.IResultDimension[], attributeHeaderItems: Execution.IResultHeaderItem[][][]): any;
export declare function getTreemapAttributes(dimensions: Execution.IResultDimension[], attributeHeaderItems: Execution.IResultHeaderItem[][][], mdObject: VisualizationObject.IVisualizationObjectContent): any;
/**
 * Creates an object providing data for all you need to render a chart except drillability.
 *
 * @param afm <executionRequest.AFM> object listing metrics and attributes used.
 * @param resultSpec <executionRequest.resultSpec> object defining expected result dimension structure,
 * @param dimensions <executionResponse.dimensions> array defining calculated dimensions and their headers,
 * @param executionResultData <executionResult.data> array with calculated data
 * @param unfilteredResultHeaderItems <executionResult.headerItems> array of attribute header items mixed with measures
 * @param config object defining chart display settings
 * @param drillableItems array of items for isPointDrillable matching
 * @return Returns composed chart options object
 */
export declare function getChartOptions(afm: AFM.IAfm, _resultSpec: AFM.IResultSpec, executionResponse: Execution.IExecutionResponse, executionResultData: Execution.DataValue[][], unfilteredResultHeaderItems: Execution.IResultHeaderItem[][][], chartConfig: IChartConfig, drillableItems: IHeaderPredicate[]): IChartOptions;

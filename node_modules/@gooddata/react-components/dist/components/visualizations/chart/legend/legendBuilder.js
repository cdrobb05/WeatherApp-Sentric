"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var pick = require("lodash/pick");
var set = require("lodash/set");
var get = require("lodash/get");
var common_1 = require("../../utils/common");
var visualizationTypes_1 = require("../../../../constants/visualizationTypes");
var legend_1 = require("../../typings/legend");
var chartOptionsBuilder_1 = require("../chartOptionsBuilder");
var helpers_1 = require("./helpers");
function isHeatmapWithMultipleValues(chartOptions) {
    var type = chartOptions.type;
    var dataClasses = get(chartOptions, "colorAxis.dataClasses", []);
    return common_1.isHeatmap(type) && dataClasses.length > 1;
}
function shouldLegendBeEnabled(chartOptions) {
    var seriesLength = get(chartOptions, "data.series.length");
    var type = chartOptions.type, hasStackByAttribute = chartOptions.hasStackByAttribute, hasViewByAttribute = chartOptions.hasViewByAttribute;
    var hasMoreThanOneSeries = seriesLength > 1;
    var isLineChartStacked = common_1.isLineChart(type) && hasStackByAttribute;
    var isStacked = helpers_1.isStackedChart(chartOptions);
    var sliceTypes = [visualizationTypes_1.VisualizationTypes.PIE, visualizationTypes_1.VisualizationTypes.DONUT];
    var isSliceChartWithViewByAttributeOrMultipleMeasures = common_1.isOneOfTypes(type, sliceTypes) && (hasViewByAttribute || chartOptions.data.series[0].data.length > 1);
    var isBubbleWithViewByAttribute = common_1.isBubbleChart(type) && hasViewByAttribute;
    var isScatterPlotWithAttribute = common_1.isScatterPlot(type) && chartOptions.data.series[0].name;
    var isTreemapWithViewByAttribute = common_1.isTreemap(type) && hasViewByAttribute;
    var isTreemapWithManyCategories = common_1.isTreemap(type) && chartOptions.data.categories.length > 1;
    return (hasMoreThanOneSeries ||
        isSliceChartWithViewByAttributeOrMultipleMeasures ||
        isStacked ||
        isLineChartStacked ||
        isScatterPlotWithAttribute ||
        isTreemapWithViewByAttribute ||
        isBubbleWithViewByAttribute ||
        isTreemapWithManyCategories ||
        isHeatmapWithMultipleValues(chartOptions));
}
exports.shouldLegendBeEnabled = shouldLegendBeEnabled;
function getLegendItems(chartOptions) {
    var type = chartOptions.type;
    var firstSeriesDataTypes = [
        visualizationTypes_1.VisualizationTypes.PIE,
        visualizationTypes_1.VisualizationTypes.DONUT,
        visualizationTypes_1.VisualizationTypes.TREEMAP,
        visualizationTypes_1.VisualizationTypes.FUNNEL,
        visualizationTypes_1.VisualizationTypes.SCATTER,
    ];
    if (common_1.isHeatmap(type)) {
        var dataClasses = get(chartOptions, "colorAxis.dataClasses", []);
        return dataClasses.map(function (dataClass, index) {
            var from = dataClass.from, to = dataClass.to;
            var color = dataClass.color; // wa are not using Gradient
            var range = {
                from: from,
                to: to,
            };
            return {
                range: range,
                color: color,
                legendIndex: index,
            };
        });
    }
    var legendDataSource = common_1.isOneOfTypes(type, firstSeriesDataTypes)
        ? chartOptions.data.series[0].data
        : chartOptions.data.series;
    var pickedProps = ["name", "color", "legendIndex"];
    if (common_1.isOneOfTypes(type, chartOptionsBuilder_1.supportedDualAxesChartTypes)) {
        // 'yAxis' helps to distinguish primary and secondary axes
        pickedProps = pickedProps.concat(["yAxis"]);
    }
    if (common_1.isComboChart(type)) {
        pickedProps = pickedProps.concat(["type"]);
    }
    return legendDataSource
        .filter(function (legendDataSourceItem) { return legendDataSourceItem.showInLegend !== false; })
        .map(function (legendDataSourceItem) { return pick(legendDataSourceItem, pickedProps); });
}
exports.getLegendItems = getLegendItems;
function getLegend(legendConfig, chartOptions) {
    if (legendConfig === void 0) { legendConfig = {}; }
    var defaultLegendConfigByType = {};
    var rightLegendCharts = [
        visualizationTypes_1.VisualizationTypes.SCATTER,
        visualizationTypes_1.VisualizationTypes.TREEMAP,
        visualizationTypes_1.VisualizationTypes.BUBBLE,
        visualizationTypes_1.VisualizationTypes.HEATMAP,
    ];
    var defaultTopLegendCharts = [
        visualizationTypes_1.VisualizationTypes.COLUMN,
        visualizationTypes_1.VisualizationTypes.BAR,
        visualizationTypes_1.VisualizationTypes.LINE,
        visualizationTypes_1.VisualizationTypes.AREA,
        visualizationTypes_1.VisualizationTypes.PIE,
        visualizationTypes_1.VisualizationTypes.DONUT,
        visualizationTypes_1.VisualizationTypes.BULLET,
        visualizationTypes_1.VisualizationTypes.PUSHPIN,
    ];
    if (legendConfig.position === "auto" || !legendConfig.position) {
        if (common_1.isOneOfTypes(chartOptions.type, rightLegendCharts)) {
            set(defaultLegendConfigByType, "position", "right");
        }
        if (common_1.isOneOfTypes(chartOptions.type, defaultTopLegendCharts) && !chartOptions.hasStackByAttribute) {
            set(defaultLegendConfigByType, "position", "top");
        }
    }
    var baseConfig = __assign({}, legend_1.DEFAULT_LEGEND_CONFIG, legendConfig, defaultLegendConfigByType);
    var isLegendEnabled = shouldLegendBeEnabled(chartOptions);
    return __assign({}, baseConfig, { enabled: baseConfig.enabled && isLegendEnabled, toggleEnabled: isLegendEnabled, format: get(chartOptions, "title.format", ""), items: getLegendItems(chartOptions) });
}
exports.default = getLegend;
//# sourceMappingURL=legendBuilder.js.map
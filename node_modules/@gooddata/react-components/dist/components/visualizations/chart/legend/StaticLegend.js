"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var React = require("react");
var cx = require("classnames");
var LegendList_1 = require("./LegendList");
var Paging_1 = require("./Paging");
var PositionTypes_1 = require("./PositionTypes");
var helpers_1 = require("./helpers");
var StaticLegend = /** @class */ (function (_super) {
    __extends(StaticLegend, _super);
    function StaticLegend(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            page: 1,
        };
        _this.showNextPage = _this.showNextPage.bind(_this);
        _this.showPrevPage = _this.showPrevPage.bind(_this);
        return _this;
    }
    StaticLegend.prototype.showNextPage = function () {
        this.setState({ page: this.state.page + 1 });
    };
    StaticLegend.prototype.showPrevPage = function () {
        this.setState({ page: this.state.page - 1 });
    };
    StaticLegend.prototype.renderPaging = function (visibleItemsCount) {
        var page = this.state.page;
        var pagesCount = Math.ceil(this.props.series.length / visibleItemsCount);
        return (React.createElement(Paging_1.default, { page: page, pagesCount: pagesCount, showNextPage: this.showNextPage, showPrevPage: this.showPrevPage }));
    };
    StaticLegend.prototype.render = function () {
        var _a = this.props, containerHeight = _a.containerHeight, chartType = _a.chartType, onItemClick = _a.onItemClick, position = _a.position, series = _a.series, _b = _a.shouldFillAvailableSpace, shouldFillAvailableSpace = _b === void 0 ? true : _b;
        var page = this.state.page;
        var classNames = cx("viz-legend", "static", "position-" + position);
        // Without paging
        if (position === PositionTypes_1.TOP || position === PositionTypes_1.BOTTOM) {
            return (React.createElement("div", { className: classNames },
                React.createElement("div", { className: "series" },
                    React.createElement(LegendList_1.default, { chartType: chartType, series: series, onItemClick: onItemClick }))));
        }
        var seriesCount = series.length;
        var _c = helpers_1.calculateStaticLegend(seriesCount, containerHeight), hasPaging = _c.hasPaging, visibleItemsCount = _c.visibleItemsCount;
        var start = (page - 1) * visibleItemsCount;
        var end = Math.min(visibleItemsCount * page, series.length);
        var pagedSeries = series.slice(start, end);
        var heightOfAvailableSpace = visibleItemsCount * helpers_1.ITEM_HEIGHT;
        var heightOfVisibleItems = Math.min(visibleItemsCount, seriesCount) * helpers_1.ITEM_HEIGHT;
        var seriesHeight = shouldFillAvailableSpace ? heightOfAvailableSpace : heightOfVisibleItems;
        return (React.createElement("div", { className: classNames },
            React.createElement("div", { className: "series", style: { height: seriesHeight } },
                React.createElement(LegendList_1.default, { chartType: chartType, series: pagedSeries, onItemClick: onItemClick })),
            hasPaging && this.renderPaging(visibleItemsCount)));
    };
    return StaticLegend;
}(React.PureComponent));
exports.default = StaticLegend;
//# sourceMappingURL=StaticLegend.js.map
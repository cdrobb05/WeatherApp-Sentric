"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cloneDeep = require("lodash/cloneDeep");
var get = require("lodash/get");
var isEmpty = require("lodash/isEmpty");
var zip = require("lodash/zip");
var invariant = require("invariant");
var calculateXirr_1 = require("./calculateXirr");
var headerPredicate_1 = require("../../../../helpers/headerPredicate");
var visualizationTypes_1 = require("../../../../constants/visualizationTypes");
var getExecutionResponseMeasureHeader = function (executionResponse) {
    return get(executionResponse, ["dimensions", 0, "headers", 0, "measureGroupHeader", "items", 0], {
        measureHeaderItem: null,
    });
};
var computeXirr = function (executionResult) {
    // prevent errors on invalid inputs
    if (!executionResult.headerItems[0][1] || !executionResult.data) {
        return NaN;
    }
    var values = executionResult.data;
    var parsedValues = values.map(function (value) { return Number.parseFloat(value); });
    var dates = executionResult.headerItems[0][1].map(function (h) { return h.attributeHeaderItem.name; });
    var transactions = zip(parsedValues, dates)
        .filter(function (_a) {
        var value = _a[0];
        return value !== 0;
    }) // zero values are irrelevant to XIRR computation, filter them out here to avoid useless Date parsing later
        .map(function (_a) {
        var amount = _a[0], date = _a[1];
        return ({
            amount: amount,
            when: new Date(date),
        });
    });
    return calculateXirr_1.calculateXirr(transactions);
};
/**
 * Get {HeadlineData} used by the {Headline} component.
 *
 * @param executionResponse - The execution response with dimensions definition.
 * @param executionResult - The execution result with an actual data values.
 */
function getHeadlineData(executionResponse, executionResult) {
    var measureHeaderItem = getExecutionResponseMeasureHeader(executionResponse).measureHeaderItem;
    var value = computeXirr(executionResult);
    invariant(value !== undefined, "Undefined execution value data for XIRR transformation");
    invariant(measureHeaderItem, "Missing expected measureHeaderItem");
    return {
        primaryItem: {
            localIdentifier: measureHeaderItem.localIdentifier,
            title: measureHeaderItem.name,
            value: value ? String(value) : null,
            format: measureHeaderItem.format,
            isDrillable: false,
        },
    };
}
exports.getHeadlineData = getHeadlineData;
/**
 * Take headline data and apply list of drillable items.
 * The method will return copied collection of the headline data with altered drillable status.
 *
 * @param headlineData - The headline data that we want to change the drillable status.
 * @param drillableItems - list of drillable items {uri, identifier}
 * @param executionRequest - Request with required measure id (uri or identifier) for activation of drill eventing
 * @param executionResponse - Response headers for drilling predicate matching
 * @returns altered headlineData
 */
function applyDrillableItems(headlineData, drillableItems, executionRequest, executionResponse) {
    var data = cloneDeep(headlineData);
    var primaryItem = data.primaryItem;
    var itemHeader = getExecutionResponseMeasureHeader(executionResponse);
    if (!isEmpty(primaryItem) && !isEmpty(itemHeader)) {
        primaryItem.isDrillable = headerPredicate_1.isSomeHeaderPredicateMatched(drillableItems, itemHeader, executionRequest.afm, executionResponse);
    }
    return data;
}
exports.applyDrillableItems = applyDrillableItems;
/**
 * Build drill event data (object with execution and drill context) from the data obtained by clicking on the {Xirr}
 * component an from the execution objects.
 *
 * @param itemContext - data received from the click on the {Xirr} component.
 * @param executionRequest - The execution request with AFM and ResultSpec.
 * @param executionResponse - The execution response with dimensions definition.
 * @returns {*}
 */
function buildDrillEventData(itemContext, executionRequest, executionResponse) {
    var measureHeaderItem = getExecutionResponseMeasureHeader(executionResponse).measureHeaderItem;
    if (!measureHeaderItem) {
        throw new Error("The measure uri has not been found in execution response!");
    }
    var intersectionElement = {
        header: {
            measureHeaderItem: measureHeaderItem,
        },
    };
    var drillContext = {
        type: visualizationTypes_1.VisualizationTypes.XIRR,
        element: "primaryValue",
        value: itemContext.value,
        intersection: [intersectionElement],
    };
    return {
        executionContext: executionRequest.afm,
        drillContext: drillContext,
    };
}
exports.buildDrillEventData = buildDrillEventData;
//# sourceMappingURL=XirrTransformationUtils.js.map
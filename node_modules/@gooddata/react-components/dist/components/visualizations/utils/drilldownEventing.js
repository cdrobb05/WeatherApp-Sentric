"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var get = require("lodash/get");
var debounce = require("lodash/debounce");
var omit = require("lodash/omit");
var without = require("lodash/without");
var CustomEvent = require("custom-event");
var invariant = require("invariant");
var visualizationTypes_1 = require("../../../constants/visualizationTypes");
var DrillEvents_1 = require("../../../interfaces/DrillEvents");
var common_1 = require("./common");
var executionResultHelper_1 = require("../../../helpers/executionResultHelper");
var executionResultHelper_2 = require("../../../helpers/geoChart/executionResultHelper");
var data_1 = require("../../../helpers/geoChart/data");
var headerPredicate_1 = require("../../../helpers/headerPredicate");
var visualizationType_1 = require("../../../helpers/visualizationType");
var MappingHeader_1 = require("../../../interfaces/MappingHeader");
var drilldownEventingLegacy_1 = require("./drilldownEventingLegacy");
function getClickableElementNameByChartType(type) {
    switch (type) {
        case visualizationTypes_1.VisualizationTypes.LINE:
        case visualizationTypes_1.VisualizationTypes.AREA:
        case visualizationTypes_1.VisualizationTypes.SCATTER:
        case visualizationTypes_1.VisualizationTypes.BUBBLE:
            return "point";
        case visualizationTypes_1.VisualizationTypes.COLUMN:
        case visualizationTypes_1.VisualizationTypes.BAR:
            return "bar";
        case visualizationTypes_1.VisualizationTypes.PIE:
        case visualizationTypes_1.VisualizationTypes.TREEMAP:
        case visualizationTypes_1.VisualizationTypes.DONUT:
        case visualizationTypes_1.VisualizationTypes.FUNNEL:
            return "slice";
        case visualizationTypes_1.VisualizationTypes.HEATMAP:
            return "cell";
        default:
            invariant(false, "Unknown visualization type: " + type);
            return null;
    }
}
exports.getClickableElementNameByChartType = getClickableElementNameByChartType;
function fireDrillEvent(onFiredDrillEvent, data, target) {
    var returnValue = onFiredDrillEvent && onFiredDrillEvent(data);
    // if user-specified onFiredDrillEvent fn returns false, do not fire default DOM event
    if (returnValue !== false) {
        var event_1 = new CustomEvent("drill", {
            detail: data,
            bubbles: true,
        });
        target.dispatchEvent(event_1);
    }
}
exports.fireDrillEvent = fireDrillEvent;
var getElementChartType = function (chartType, point) {
    return get(point, "series.type", chartType);
};
var getDrillPointCustomProps = function (point, chartType) {
    if (common_1.isComboChart(chartType)) {
        return { type: get(point, "series.type") };
    }
    if (common_1.isBulletChart(chartType)) {
        return { type: get(point, "series.userOptions.bulletChartMeasureType") };
    }
    return {};
};
var getYValueForBulletChartTarget = function (point) {
    if (point.isNullTarget) {
        return null;
    }
    return point.target;
};
var getDrillPoint = function (chartType) { return function (point) {
    var customProps = getDrillPointCustomProps(point, chartType);
    var elementChartType = getElementChartType(chartType, point);
    var result = __assign({ x: point.x, y: elementChartType === "bullet" ? getYValueForBulletChartTarget(point) : point.y, intersection: point.drillIntersection }, customProps);
    return result;
}; };
function composeDrillContextGroup(points, chartType) {
    var sanitizedPoints = sanitizeContextPoints(chartType, points);
    var contextPoints = sanitizedPoints.map(getDrillPoint(chartType));
    return {
        type: chartType,
        element: "label",
        points: contextPoints,
    };
}
function getClickableElementNameForBulletChart(point) {
    return point.series.userOptions.bulletChartMeasureType;
}
function composeDrillContextPoint(point, chartType) {
    var zProp = isNaN(point.z) ? {} : { z: point.z };
    var valueProp = common_1.isTreemap(chartType) || common_1.isHeatmap(chartType)
        ? {
            value: point.value ? point.value.toString() : "",
        }
        : {};
    var elementChartType = getElementChartType(chartType, point);
    var xyProp = common_1.isTreemap(chartType)
        ? {}
        : {
            x: point.x,
            y: elementChartType === "bullet" ? point.target : point.y,
        };
    var customProp = common_1.isComboChart(chartType)
        ? {
            elementChartType: elementChartType,
        }
        : {};
    return __assign({ type: chartType, element: common_1.isBulletChart(chartType)
            ? getClickableElementNameForBulletChart(point)
            : getClickableElementNameByChartType(elementChartType), intersection: point.drillIntersection }, xyProp, zProp, valueProp, customProp);
}
var chartClickDebounced = debounce(function (drillConfig, event, target, chartType) {
    var afm = drillConfig.afm, onFiredDrillEvent = drillConfig.onFiredDrillEvent, onDrill = drillConfig.onDrill;
    var type = visualizationType_1.getVisualizationType(chartType);
    var drillContext = null;
    if (DrillEvents_1.isGroupHighchartsDrillEvent(event)) {
        var points = event.points;
        drillContext = composeDrillContextGroup(points, type);
    }
    else {
        var point = event.point;
        drillContext = composeDrillContextPoint(point, type);
    }
    var drillEventExtended = {
        executionContext: afm,
        drillContext: drillContext,
    };
    if (onDrill) {
        onDrill(drillEventExtended);
    }
    var drillContextLegacy = drilldownEventingLegacy_1.convertDrillContextToLegacy(drillContext, afm);
    var drillEventLegacy = {
        executionContext: afm,
        drillContext: drillContextLegacy,
    };
    fireDrillEvent(onFiredDrillEvent, drillEventLegacy, target);
});
function chartClick(drillConfig, event, target, chartType) {
    chartClickDebounced(drillConfig, event, target, chartType);
}
exports.chartClick = chartClick;
var getDrillEvent = function (points, chartType, afm) {
    var contextPoints = points.map(function (point) {
        var customProps = common_1.isBulletChart(chartType)
            ? { type: get(point, "series.userOptions.bulletChartMeasureType") }
            : {};
        return __assign({ x: point.x, y: point.y, intersection: point.drillIntersection }, customProps);
    });
    var drillContext = {
        type: chartType,
        element: "label",
        points: contextPoints,
    };
    return {
        executionContext: afm,
        drillContext: drillContext,
    };
};
var tickLabelClickDebounce = debounce(function (drillConfig, points, target, chartType) {
    var afm = drillConfig.afm, onFiredDrillEvent = drillConfig.onFiredDrillEvent, onDrill = drillConfig.onDrill;
    var sanitizedPoints = sanitizeContextPoints(chartType, points);
    var dataExtended = getDrillEvent(sanitizedPoints, chartType, afm);
    if (onDrill) {
        onDrill(dataExtended);
    }
    var drillContext = drilldownEventingLegacy_1.convertDrillContextToLegacy(dataExtended.drillContext, afm);
    var data = {
        executionContext: afm,
        drillContext: drillContext,
    };
    fireDrillEvent(onFiredDrillEvent, data, target);
});
function sanitizeContextPoints(chartType, points) {
    if (common_1.isHeatmap(chartType)) {
        return points.filter(function (point) { return !point.ignoredInDrillEventContext; });
    }
    return points;
}
function tickLabelClick(drillConfig, points, target, chartType) {
    tickLabelClickDebounce(drillConfig, points, target, chartType);
}
exports.tickLabelClick = tickLabelClick;
function cellClick(drillConfig, event, target) {
    var afm = drillConfig.afm, onFiredDrillEvent = drillConfig.onFiredDrillEvent;
    var columnIndex = event.columnIndex, rowIndex = event.rowIndex, row = event.row, intersection = event.intersection;
    var drillContext = {
        type: visualizationTypes_1.VisualizationTypes.TABLE,
        element: "cell",
        columnIndex: columnIndex,
        rowIndex: rowIndex,
        row: row,
        intersection: intersection,
    };
    var data = {
        executionContext: afm,
        drillContext: drillContext,
    };
    fireDrillEvent(onFiredDrillEvent, data, target);
}
exports.cellClick = cellClick;
function createDrillIntersectionElement(id, title, uri, identifier) {
    var element = {
        id: id || "",
        title: title || "",
    };
    if (uri || identifier) {
        element.header = {
            uri: uri || "",
            identifier: identifier || "",
        };
    }
    return element;
}
exports.createDrillIntersectionElement = createDrillIntersectionElement;
// shared by charts and table
exports.getDrillIntersection = function (drillItems) {
    return drillItems.reduce(function (drillIntersection, drillItem, index, drillItems) {
        if (MappingHeader_1.isMappingHeaderAttribute(drillItem)) {
            var attributeItem = drillItems[index - 1]; // attribute item is always before attribute
            if (attributeItem && MappingHeader_1.isMappingHeaderAttributeItem(attributeItem)) {
                drillIntersection.push({
                    header: __assign({}, attributeItem, drillItem),
                });
            }
            else {
                // no attr. item before attribute -> use only attribute header
                drillIntersection.push({
                    header: drillItem,
                });
            }
        }
        else if (MappingHeader_1.isMappingHeaderMeasureItem(drillItem)) {
            drillIntersection.push({
                header: drillItem,
            });
        }
        return drillIntersection;
    }, []);
};
function getDrillIntersectionForGeoChart(drillableItems, drillConfig, execution, geoData, locationIndex) {
    var executionResponse = execution.executionResponse;
    var dimensions = executionResponse.dimensions;
    var _a = (executionResultHelper_1.findMeasureGroupInDimensions(dimensions) || {}).items, measureGroupItems = _a === void 0 ? [] : _a;
    var measureHeaders = measureGroupItems.slice(0, 2);
    var _b = executionResultHelper_2.findGeoAttributesInDimension(execution, geoData), locationAttribute = _b.locationAttribute, segmentByAttribute = _b.segmentByAttribute, tooltipTextAttribute = _b.tooltipTextAttribute;
    var _c = getAttributeHeader(locationAttribute, locationIndex), locationAttributeHeader = _c.attributeHeader, locationAttributeHeaderItem = _c.attributeHeaderItem;
    var _d = getAttributeHeader(segmentByAttribute, locationIndex), segmentByAttributeHeader = _d.attributeHeader, segmentByAttributeHeaderItem = _d.attributeHeaderItem;
    var _e = getAttributeHeader(tooltipTextAttribute, locationIndex), tooltipTextAttributeHeader = _e.attributeHeader, tooltipTextAttributeHeaderItem = _e.attributeHeaderItem;
    // pin is drillable if a drillableItem matches:
    //   pin's measure,
    //   pin's location attribute,
    //   pin's location attribute item,
    //   pin's segmentBy attribute,
    //   pin's segmentBy attribute item,
    //   pin's tooltipText attribute,
    //   pin's tooltipText attribute item,
    var drillItems = without(measureHeaders.concat([
        locationAttributeHeaderItem,
        locationAttributeHeader,
        segmentByAttributeHeaderItem,
        segmentByAttributeHeader,
        tooltipTextAttributeHeaderItem,
        tooltipTextAttributeHeader,
    ]), undefined);
    var drilldown = drillItems.some(function (drillableHook) {
        return headerPredicate_1.isSomeHeaderPredicateMatched(drillableItems, drillableHook, drillConfig.afm, executionResponse);
    });
    if (drilldown) {
        return exports.getDrillIntersection(drillItems);
    }
    return undefined;
}
function getAttributeHeader(attribute, dataIndex) {
    if (attribute) {
        return {
            attributeHeader: { attributeHeader: omit(attribute, "items") },
            attributeHeaderItem: attribute.items[dataIndex],
        };
    }
    return {
        attributeHeader: undefined,
        attributeHeaderItem: undefined,
    };
}
function handleGeoPushpinDrillEvent(drillableItems, drillConfig, execution, geoData, pinProperties, pinCoordinates, target) {
    var locationIndex = pinProperties.locationIndex;
    var drillIntersection = getDrillIntersectionForGeoChart(drillableItems, drillConfig, execution, geoData, locationIndex);
    if (!drillIntersection || !drillIntersection.length) {
        return;
    }
    var afm = drillConfig.afm, onDrill = drillConfig.onDrill, onFiredDrillEvent = drillConfig.onFiredDrillEvent;
    var lng = pinCoordinates[0], lat = pinCoordinates[1];
    var _a = data_1.parseGeoProperties(pinProperties), locationNameValue = _a.locationName.value, colorValue = _a.color.value, segmentByValue = _a.segment.value, sizeValue = _a.size.value;
    var drillContext = {
        element: "pushpin",
        intersection: drillIntersection,
        type: "pushpin",
        color: colorValue,
        location: { lat: lat, lng: lng },
        locationName: locationNameValue,
        segmentBy: segmentByValue,
        size: sizeValue,
    };
    var drillEventExtended = {
        executionContext: afm,
        drillContext: drillContext,
    };
    if (onDrill) {
        onDrill(drillEventExtended);
    }
    var drillContextLegacy = drilldownEventingLegacy_1.convertDrillContextToLegacy(drillContext, afm);
    var drillEventLegacy = {
        executionContext: afm,
        drillContext: drillContextLegacy,
    };
    fireDrillEvent(onFiredDrillEvent, drillEventLegacy, target);
}
exports.handleGeoPushpinDrillEvent = handleGeoPushpinDrillEvent;
//# sourceMappingURL=drilldownEventing.js.map
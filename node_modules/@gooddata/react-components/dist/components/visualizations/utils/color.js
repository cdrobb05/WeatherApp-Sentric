"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var isEmpty = require("lodash/isEmpty");
var isEqual = require("lodash/isEqual");
var isString = require("lodash/isString");
var range = require("lodash/range");
var MappingHeader_1 = require("../../../interfaces/MappingHeader");
var mappingHeader_1 = require("../../../helpers/mappingHeader");
exports.WHITE = "rgb(255, 255, 255)";
exports.BLACK = "rgb(0, 0, 0)";
exports.GRAY = "rgb(201, 213, 223)";
exports.AXIS_LINE_COLOR = "#d5d5d5";
exports.TRANSPARENT = "transparent";
exports.DEFAULT_COLORS = [
    "rgb(20,178,226)",
    "rgb(0,193,141)",
    "rgb(229,77,66)",
    "rgb(241,134,0)",
    "rgb(171,85,163)",
    "rgb(244,213,33)",
    "rgb(148,161,174)",
    "rgb(107,191,216)",
    "rgb(181,136,177)",
    "rgb(238,135,128)",
    "rgb(241,171,84)",
    "rgb(133,209,188)",
    "rgb(41,117,170)",
    "rgb(4,140,103)",
    "rgb(181,60,51)",
    "rgb(163,101,46)",
    "rgb(140,57,132)",
    "rgb(136,219,244)",
    "rgb(189,234,222)",
    "rgb(239,197,194)",
];
exports.DEFAULT_COLOR_PALETTE = [
    {
        guid: "1",
        fill: { r: 20, g: 178, b: 226 },
    },
    {
        guid: "2",
        fill: { r: 0, g: 193, b: 141 },
    },
    {
        guid: "3",
        fill: { r: 229, g: 77, b: 66 },
    },
    {
        guid: "4",
        fill: { r: 241, g: 134, b: 0 },
    },
    {
        guid: "5",
        fill: { r: 171, g: 85, b: 163 },
    },
    {
        guid: "6",
        fill: { r: 244, g: 213, b: 33 },
    },
    {
        guid: "7",
        fill: { r: 148, g: 161, b: 174 },
    },
    {
        guid: "8",
        fill: { r: 107, g: 191, b: 216 },
    },
    {
        guid: "9",
        fill: { r: 181, g: 136, b: 177 },
    },
    {
        guid: "10",
        fill: { r: 238, g: 135, b: 128 },
    },
    {
        guid: "11",
        fill: { r: 241, g: 171, b: 84 },
    },
    {
        guid: "12",
        fill: { r: 133, g: 209, b: 188 },
    },
    {
        guid: "13",
        fill: { r: 41, g: 117, b: 170 },
    },
    {
        guid: "14",
        fill: { r: 4, g: 140, b: 103 },
    },
    {
        guid: "15",
        fill: { r: 181, g: 60, b: 51 },
    },
    {
        guid: "16",
        fill: { r: 163, g: 101, b: 46 },
    },
    {
        guid: "17",
        fill: { r: 140, g: 57, b: 132 },
    },
    {
        guid: "18",
        fill: { r: 136, g: 219, b: 244 },
    },
    {
        guid: "19",
        fill: { r: 189, g: 234, b: 222 },
    },
    {
        guid: "20",
        fill: { r: 239, g: 197, b: 194 },
    },
];
exports.HEATMAP_BLUE_COLOR_PALETTE = [
    "rgb(255,255,255)",
    "rgb(197,236,248)",
    "rgb(138,217,241)",
    "rgb(79,198,234)",
    "rgb(20,178,226)",
    "rgb(22,151,192)",
    "rgb(0,110,145)",
];
exports.DEFAULT_HEATMAP_BLUE_COLOR = {
    r: 0,
    g: 110,
    b: 145,
};
exports.DEFAULT_BULLET_GRAY_COLOR = {
    r: 217,
    g: 220,
    b: 226,
};
function lighter(color, percent) {
    var t = percent < 0 ? 0 : 255;
    var p = Math.abs(percent);
    return Math.round((t - color) * p) + color;
}
function formatColor(red, green, blue, opacity) {
    if (opacity === void 0) { opacity = 1; }
    if (opacity === 1) {
        return "rgb(" + red + "," + green + "," + blue + ")";
    }
    return "rgba(" + red + "," + green + "," + blue + "," + opacity + ")";
}
function parseRGBColorCode(color) {
    var f = color.split(",");
    var R = parseInt(f[0].slice(4), 10);
    var G = parseInt(f[1], 10);
    var B = parseInt(f[2], 10);
    return { R: R, G: G, B: B };
}
exports.parseRGBColorCode = parseRGBColorCode;
/**
 * Source:
 *     http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
 */
function getLighterColor(color, percent) {
    var _a = parseRGBColorCode(color), R = _a.R, G = _a.G, B = _a.B;
    return formatColor(lighter(R, percent), lighter(G, percent), lighter(B, percent));
}
exports.getLighterColor = getLighterColor;
function getLighterColorFromRGB(color, percent) {
    var r = color.r, g = color.g, b = color.b;
    return {
        r: lighter(r, percent),
        g: lighter(g, percent),
        b: lighter(b, percent),
    };
}
exports.getLighterColorFromRGB = getLighterColorFromRGB;
function normalizeColorToRGB(color) {
    var hexPattern = /#([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})/i;
    return color.replace(hexPattern, function (_prefix, r, g, b) {
        return "rgb(" + [r, g, b].map(function (value) { return parseInt(value, 16).toString(10); }).join(", ") + ")";
    });
}
exports.normalizeColorToRGB = normalizeColorToRGB;
function getColorPaletteFromColors(colors) {
    try {
        return colors.map(function (color, index) {
            var _a = parseRGBColorCode(normalizeColorToRGB(color)), R = _a.R, G = _a.G, B = _a.B;
            if (isNaN(R) || isNaN(G) || isNaN(B)) {
                throw Error;
            }
            return {
                guid: String(index),
                fill: {
                    r: R,
                    g: G,
                    b: B,
                },
            };
        });
    }
    catch (_ignored) {
        return exports.DEFAULT_COLOR_PALETTE;
    }
}
exports.getColorPaletteFromColors = getColorPaletteFromColors;
function getRgbString(color) {
    return "rgb(" + color.fill.r + "," + color.fill.g + "," + color.fill.b + ")";
}
exports.getRgbString = getRgbString;
function getValidColorPalette(colors, colorPalette) {
    return isEmpty(colorPalette)
        ? isEmpty(colors)
            ? exports.DEFAULT_COLOR_PALETTE
            : getColorPaletteFromColors(colors)
        : colorPalette;
}
exports.getValidColorPalette = getValidColorPalette;
function isCustomPalette(palette) {
    return !isEqual(palette, exports.DEFAULT_COLOR_PALETTE);
}
exports.isCustomPalette = isCustomPalette;
function getColorFromMapping(mappingHeader, colorMapping, executionResponse, afm) {
    if (!colorMapping) {
        return undefined;
    }
    var mapping = colorMapping.find(function (item) { return item.predicate(mappingHeader, { afm: afm, executionResponse: executionResponse }); });
    return mapping && mapping.color;
}
exports.getColorFromMapping = getColorFromMapping;
function getColorByGuid(colorPalette, guid, index) {
    var inPalette = colorPalette.find(function (item) { return item.guid === guid; });
    return inPalette ? inPalette.fill : colorPalette[index % colorPalette.length].fill;
}
exports.getColorByGuid = getColorByGuid;
function getRgbStringFromRGB(color) {
    return "rgb(" + color.r + "," + color.g + "," + color.b + ")";
}
exports.getRgbStringFromRGB = getRgbStringFromRGB;
function getColorMappingPredicate(idOrUri) {
    return function (header, _context) {
        if (MappingHeader_1.isMappingHeaderAttributeItem(header)) {
            return idOrUri ? idOrUri === header.attributeHeaderItem.uri : false;
        }
        if (MappingHeader_1.isMappingHeaderAttribute(header)) {
            return idOrUri ? idOrUri === header.attributeHeader.uri : false;
        }
        var headerLocalIdentifier = mappingHeader_1.getMappingHeaderLocalIdentifier(header);
        return headerLocalIdentifier ? headerLocalIdentifier === idOrUri : false;
    };
}
exports.getColorMappingPredicate = getColorMappingPredicate;
function getCalculatedChannel(channel, index, step) {
    return Math.trunc(channel + index * step);
}
function getCalculatedColors(count, channels, steps, opacity) {
    if (opacity === void 0) { opacity = 1; }
    return range(1, count).map(function (index) {
        return formatColor(getCalculatedChannel(channels[0], index, steps[0]), getCalculatedChannel(channels[1], index, steps[1]), getCalculatedChannel(channels[2], index, steps[2]), opacity);
    });
}
function getRGBColorCode(color) {
    if (isString(color)) {
        var _a = parseRGBColorCode(color), r = _a.R, g = _a.G, b = _a.B;
        return {
            r: r,
            g: g,
            b: b,
        };
    }
    return color;
}
function getColorPalette(baseColor, opacity) {
    if (opacity === void 0) { opacity = 1; }
    var colorItemsCount = 6;
    var _a = getRGBColorCode(baseColor), r = _a.r, g = _a.g, b = _a.b;
    var channels = [r, g, b];
    var steps = channels.map(function (channel) { return (255 - channel) / colorItemsCount; });
    var generatedColors = getCalculatedColors(colorItemsCount, channels, steps, opacity);
    return generatedColors.reverse().concat([formatColor(r, g, b, opacity)]);
}
exports.getColorPalette = getColorPalette;
function rgbToRgba(color, opacity) {
    if (opacity === void 0) { opacity = 1; }
    var _a = parseRGBColorCode(color), R = _a.R, G = _a.G, B = _a.B;
    return formatColor(R, G, B, opacity);
}
exports.rgbToRgba = rgbToRgba;
// For re-exporting in index.ts
// Create object here since TSC can't reexport external types used by getColorMappingPredicate
exports.default = {
    getColorByGuid: getColorByGuid,
    getColorMappingPredicate: getColorMappingPredicate,
};
//# sourceMappingURL=color.js.map
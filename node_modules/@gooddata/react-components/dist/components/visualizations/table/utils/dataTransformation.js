"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2018 GoodData Corporation
var typings_1 = require("@gooddata/typings");
var invariant = require("invariant");
var get = require("lodash/get");
var has = require("lodash/has");
var isEmpty = require("lodash/isEmpty");
var zip = require("lodash/zip");
var mappingHeader_1 = require("../../../../helpers/mappingHeader");
var MappingHeader_1 = require("../../../../interfaces/MappingHeader");
var Table_1 = require("../../../../interfaces/Table");
var common_1 = require("../../utils/common");
var afmHelper_1 = require("../../../../helpers/afmHelper");
var drilldownEventing_1 = require("../../utils/drilldownEventing");
var utils_1 = require("../totals/utils");
function getHeaders(executionResponse) {
    var dimensions = get(executionResponse, "dimensions", []);
    // two dimensions must be always returned (and requested)
    invariant(dimensions.length === 2, "Number of dimensions must be equal two");
    // attributes are always returned (and requested) in 0-th dimension
    var attributeHeaders = dimensions[0].headers.filter(typings_1.Execution.isAttributeHeader);
    // measures are always returned (and requested) in 1-st dimension
    var measureHeaders = get(dimensions[1].headers.find(typings_1.Execution.isMeasureGroupHeader), ["measureGroupHeader", "items"], []);
    return attributeHeaders.concat(measureHeaders);
}
exports.getHeaders = getHeaders;
function isMatrix(dataValues) {
    return dataValues[0] instanceof Array;
}
function getRows(executionResult) {
    // two dimensional headerItems array are always returned (and requested)
    // attributes are always returned (and requested) in 0-th dimension
    var attributeValues = executionResult.headerItems[0]
        .filter(
    // filter only arrays which contains some attribute header items
    function (headerItem) {
        return headerItem.some(function (item) { return has(item, "attributeHeaderItem"); });
    })
        .map(function (attributeHeaderItems) {
        return attributeHeaderItems.map(function (attributeHeaderItem) {
            return get(attributeHeaderItem, "attributeHeaderItem");
        });
    });
    var dataValues = get(executionResult, "data", []);
    var attributeRows = zip.apply(void 0, attributeValues);
    if (dataValues.length === 0) {
        return attributeRows;
    }
    if (isMatrix(dataValues)) {
        var measureValues = dataValues;
        if (attributeRows.length === 0) {
            return measureValues;
        }
        return measureValues.map(function (measureValue, index) {
            return attributeRows[index].concat(measureValue);
        });
    }
}
exports.getRows = getRows;
function getResultTotalsValues(executionResult) {
    var totalsData = executionResult.totals;
    if (!isEmpty(totalsData)) {
        // Totals are requested and returned in the same dimension as attributes,
        // and in case of Table, attributes are always in 0-th dimension
        return totalsData[0];
    }
    return [];
}
function isResultTotalHeaderItem(headerItem) {
    return headerItem.totalHeaderItem !== undefined;
}
function getOrderedTotalTypes(executionResult) {
    // Totals are requested (and returned) in the same dimension as attributes, and in case of Table,
    // attributes are always in 0-th dimension right now, therefore executionResult.headerItems[0].
    // Also, we are now supporting only Grand Totals, so totals will be returned always next to the headerItems
    // of the first attribute, therefore executionResult.headerItems[0][0]
    var headerItems = get(executionResult, "headerItems[0][0]", []);
    return headerItems.reduce(function (types, headerItem) {
        if (isResultTotalHeaderItem(headerItem)) {
            types.push(headerItem.totalHeaderItem.type);
        }
        return types;
    }, []);
}
function getTotalsWithData(totalsDefinition, executionResult) {
    var totalsResultValues = getResultTotalsValues(executionResult);
    if (isEmpty(totalsDefinition)) {
        return [];
    }
    var orderedTotalsTypes = getOrderedTotalTypes(executionResult);
    if (!orderedTotalsTypes.length) {
        orderedTotalsTypes = utils_1.AVAILABLE_TOTALS;
    }
    var index = 0;
    return orderedTotalsTypes.reduce(function (totals, type) {
        var totalDefinition = totalsDefinition.find(function (total) { return total.type === type; });
        if (totalDefinition) {
            totals.push(__assign({}, totalDefinition, { values: isEmpty(totalsResultValues) ? [] : totalsResultValues[index] || [] }));
            index += 1;
        }
        return totals;
    }, []);
}
exports.getTotalsWithData = getTotalsWithData;
function validateTableProportions(headers, rows) {
    invariant(rows.length === 0 || headers.length === rows[0].length, "Number of table columns must be equal to number of table headers");
}
exports.validateTableProportions = validateTableProportions;
function getIntersectionForDrilling(afm, header) {
    if (MappingHeader_1.isMappingHeaderAttribute(header)) {
        return drilldownEventing_1.createDrillIntersectionElement(mappingHeader_1.getMappingHeaderIdentifier(header), mappingHeader_1.getMappingHeaderName(header), mappingHeader_1.getMappingHeaderUri(header), mappingHeader_1.getMappingHeaderIdentifier(header));
    }
    if (MappingHeader_1.isMappingHeaderMeasureItem(header)) {
        var masterMeasureQualifier = afmHelper_1.getMasterMeasureObjQualifier(afm, mappingHeader_1.getMappingHeaderLocalIdentifier(header));
        var uri = masterMeasureQualifier.uri || mappingHeader_1.getMappingHeaderUri(header);
        var identifier = masterMeasureQualifier.identifier || mappingHeader_1.getMappingHeaderIdentifier(header);
        return drilldownEventing_1.createDrillIntersectionElement(mappingHeader_1.getMappingHeaderLocalIdentifier(header), mappingHeader_1.getMappingHeaderName(header), uri, identifier);
    }
    throw new Error("Unknown mapping header type " + Object.keys(header));
}
exports.getIntersectionForDrilling = getIntersectionForDrilling;
function getBackwardCompatibleRowForDrilling(row) {
    return row.map(function (cell) {
        return Table_1.isAttributeCell(cell)
            ? {
                id: common_1.getAttributeElementIdFromAttributeElementUri(cell.uri),
                name: cell.name,
            }
            : cell;
    });
}
exports.getBackwardCompatibleRowForDrilling = getBackwardCompatibleRowForDrilling;
//# sourceMappingURL=dataTransformation.js.map
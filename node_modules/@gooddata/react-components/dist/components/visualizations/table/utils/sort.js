"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2018 GoodData Corporation
var classNames = require("classnames");
var invariant = require("invariant");
var first = require("lodash/first");
var get = require("lodash/get");
var typings_1 = require("@gooddata/typings");
var sort_1 = require("../../../../constants/sort");
var MappingHeader_1 = require("../../../../interfaces/MappingHeader");
var isAttributeSortItem = typings_1.AFM.isAttributeSortItem;
function getSortBy(tableHeaders, sortItemLocalIdentifier) {
    var sortByColumnIndex = tableHeaders.findIndex(function (tableHeader) {
        if (MappingHeader_1.isMappingHeaderMeasureItem(tableHeader)) {
            return tableHeader.measureHeaderItem.localIdentifier === sortItemLocalIdentifier;
        }
        if (MappingHeader_1.isMappingHeaderAttribute(tableHeader)) {
            return tableHeader.attributeHeader.localIdentifier === sortItemLocalIdentifier;
        }
    });
    invariant(sortByColumnIndex >= 0, "Cannot find sort identifier " + sortItemLocalIdentifier + " in table headers");
    return sortByColumnIndex;
}
function getSortItemAttributeIdentifier(sortItem) {
    return get(sortItem, ["attributeSortItem", "attributeIdentifier"]);
}
function getSortItemMeasureIdentifier(sortItem) {
    var locators = get(sortItem, ["measureSortItem", "locators"]);
    invariant(locators.length <= 1, "Measure sort item couldn't contain more than one locator");
    var firstLocator = first(locators);
    return get(firstLocator, ["measureLocatorItem", "measureIdentifier"]);
}
function getHeaderSortClassName(sortDir, currentSort) {
    return classNames({
        "gd-table-arrow-up": sortDir === sort_1.ASC,
        "gd-table-arrow-down": sortDir === sort_1.DESC,
        "s-sorted-asc": currentSort === sort_1.ASC,
        "s-sorted-desc": currentSort === sort_1.DESC,
    });
}
exports.getHeaderSortClassName = getHeaderSortClassName;
function getNextSortDir(header, currentSortDir) {
    if (!currentSortDir) {
        return MappingHeader_1.isMappingHeaderMeasureItem(header) ? sort_1.DESC : sort_1.ASC;
    }
    return currentSortDir === sort_1.ASC ? sort_1.DESC : sort_1.ASC;
}
exports.getNextSortDir = getNextSortDir;
function getSortItem(executionRequest) {
    var sorts = get(executionRequest, ["execution", "resultSpec", "sorts"], []);
    if (sorts.length === 0) {
        return null;
    }
    invariant(sorts.length === 1, "Table allows only one sort");
    return sorts[0];
}
exports.getSortItem = getSortItem;
function getSortInfo(sortItem, tableHeaders) {
    if (isAttributeSortItem(sortItem)) {
        var sortItemIdentifier_1 = getSortItemAttributeIdentifier(sortItem);
        var sortBy_1 = getSortBy(tableHeaders, sortItemIdentifier_1);
        var sortDir_1 = get(sortItem, ["attributeSortItem", "direction"]);
        return { sortBy: sortBy_1, sortDir: sortDir_1 };
    }
    var sortItemIdentifier = getSortItemMeasureIdentifier(sortItem);
    var sortBy = getSortBy(tableHeaders, sortItemIdentifier);
    var sortDir = get(sortItem, ["measureSortItem", "direction"]);
    return { sortBy: sortBy, sortDir: sortDir };
}
exports.getSortInfo = getSortInfo;
function createSortItem(header, sortObj) {
    if (MappingHeader_1.isMappingHeaderMeasureItem(header)) {
        return {
            measureSortItem: {
                direction: sortObj.nextDir,
                locators: [
                    {
                        measureLocatorItem: {
                            measureIdentifier: header.measureHeaderItem.localIdentifier,
                        },
                    },
                ],
            },
        };
    }
    if (MappingHeader_1.isMappingHeaderAttribute(header)) {
        return {
            attributeSortItem: {
                direction: sortObj.nextDir,
                attributeIdentifier: header.attributeHeader.localIdentifier,
            },
        };
    }
    throw new Error("Unknown mapping header type " + Object.keys(header));
}
exports.createSortItem = createSortItem;
//# sourceMappingURL=sort.js.map
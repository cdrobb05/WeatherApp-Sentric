"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2021 GoodData Corporation
var remove = require("lodash/remove");
var cloneDeep = require("lodash/cloneDeep");
var sortedUniq = require("lodash/sortedUniq");
var clone = require("lodash/clone");
var without = require("lodash/without");
var omit = require("lodash/omit");
var sortBy = require("lodash/sortBy");
var get = require("lodash/get");
var MappingHeader_1 = require("../../../../interfaces/MappingHeader");
var layout_1 = require("../utils/layout");
exports.AVAILABLE_TOTALS = ["sum", "max", "min", "avg", "med", "nat"];
exports.isNativeTotal = function (total) {
    return total && total.type === "nat";
};
exports.getAttributeDimension = function (attributeIdentifier, resultSpec) {
    return resultSpec.dimensions.find(function (dimension) { return !!dimension.itemIdentifiers.find(function (attribute) { return attribute === attributeIdentifier; }); });
};
var getNativeTotalAttributeIdentifiers = function (total, resultSpec) {
    var attributeIdentifiers = exports.getAttributeDimension(total.attributeIdentifier, resultSpec).itemIdentifiers;
    var totalAttributeIndex = attributeIdentifiers.findIndex(function (attributeIdentifier) { return attributeIdentifier === total.attributeIdentifier; });
    return attributeIdentifiers.slice(0, totalAttributeIndex);
};
exports.getNativeTotals = function (totals, resultSpec) {
    if (!totals) {
        return [];
    }
    var afmNativeTotals = totals
        .filter(function (total) { return exports.isNativeTotal(total); })
        .map(function (nativeTotal) { return ({
        measureIdentifier: nativeTotal.measureIdentifier,
        attributeIdentifiers: getNativeTotalAttributeIdentifiers(nativeTotal, resultSpec),
    }); });
    return afmNativeTotals;
};
exports.getTotalsFromResultSpec = function (resultSpec) {
    return resultSpec && resultSpec.dimensions
        ? resultSpec.dimensions.reduce(function (totals, dimension) {
            return dimension && dimension.totals ? totals.concat(dimension.totals) : totals;
        }, [])
        : [];
};
function getTotalsList(intl) {
    return exports.AVAILABLE_TOTALS.map(function (type) { return ({
        type: type,
        title: intl.formatMessage({ id: "visualizations.totals.dropdown.title." + type }),
    }); });
}
function getTotalsDataSource(usedTotals, intl) {
    var usedTotalsTypes = usedTotals.map(function (total) { return total.type; });
    var list = getTotalsList(intl).map(function (total) { return (__assign({}, total, { disabled: usedTotalsTypes.includes(total.type) })); });
    list.unshift({
        title: "visualizations.totals.dropdown.heading",
        role: "header",
    });
    return {
        rowsCount: list.length,
        getObjectAt: function (index) { return list[index]; },
    };
}
exports.getTotalsDataSource = getTotalsDataSource;
function createTotalItem(type, outputMeasureIndexes, values) {
    if (outputMeasureIndexes === void 0) { outputMeasureIndexes = []; }
    if (values === void 0) { values = []; }
    return {
        type: type,
        outputMeasureIndexes: outputMeasureIndexes,
        values: values,
    };
}
exports.createTotalItem = createTotalItem;
function orderTotals(totalsUnordered) {
    return sortBy(totalsUnordered, function (total) { return exports.AVAILABLE_TOTALS.indexOf(total.type); });
}
exports.orderTotals = orderTotals;
function toggleCellClass(parentReference, tableColumnIndex, isHighlighted, className) {
    var cells = parentReference.querySelectorAll(".col-" + tableColumnIndex);
    Array.from(cells).forEach(function (cell) {
        if (isHighlighted) {
            cell.classList.add(className);
        }
        else {
            cell.classList.remove(className);
        }
    });
}
exports.toggleCellClass = toggleCellClass;
function resetRowClass(parentReference, className, selector, rowIndexToBeSet) {
    if (rowIndexToBeSet === void 0) { rowIndexToBeSet = null; }
    var rows = parentReference.querySelectorAll(selector);
    Array.from(rows).forEach(function (r) { return r.classList.remove(className); });
    if (rows.length && rowIndexToBeSet !== null) {
        var row = rows[rowIndexToBeSet];
        row.classList.add(className);
    }
}
exports.resetRowClass = resetRowClass;
function removeTotalsRow(totals, totalItemTypeToRemove) {
    var updatedTotals = cloneDeep(totals);
    remove(updatedTotals, function (total) { return total.type === totalItemTypeToRemove; });
    return updatedTotals;
}
exports.removeTotalsRow = removeTotalsRow;
function isTotalUsed(totals, totalItemType) {
    return totals.some(function (row) { return row.type === totalItemType; });
}
exports.isTotalUsed = isTotalUsed;
function addTotalsRow(totals, totalItemTypeToAdd) {
    var updatedTotals = cloneDeep(totals);
    if (isTotalUsed(updatedTotals, totalItemTypeToAdd)) {
        return updatedTotals;
    }
    var total = createTotalItem(totalItemTypeToAdd);
    updatedTotals.push(total);
    return updatedTotals;
}
exports.addTotalsRow = addTotalsRow;
function updateTotalsRemovePosition(tableBoundingRect, totals, isTotalsEditAllowed, totalsAreVisible, removeWrapper) {
    if (!isTotalsEditAllowed) {
        return;
    }
    var translateY = tableBoundingRect.height - layout_1.getFooterHeight(totals, isTotalsEditAllowed, totalsAreVisible);
    removeWrapper.style.bottom = "auto";
    removeWrapper.style.top = translateY + "px";
}
exports.updateTotalsRemovePosition = updateTotalsRemovePosition;
function getAddTotalDropdownAlignPoints(isLastColumn) {
    if (isLastColumn === void 0) { isLastColumn = false; }
    return isLastColumn
        ? [
            { align: "tc br", offset: { x: 30, y: -3 } },
            { align: "bc tr", offset: { x: 30, y: 50 } },
        ]
        : [
            { align: "tc bc", offset: { x: 0, y: -3 } },
            { align: "bc tc", offset: { x: 0, y: 50 } },
        ];
}
exports.getAddTotalDropdownAlignPoints = getAddTotalDropdownAlignPoints;
function shouldShowAddTotalButton(header, isFirstColumn, addingMoreTotalsEnabled) {
    return !isFirstColumn && MappingHeader_1.isMappingHeaderMeasureItem(header) && addingMoreTotalsEnabled;
}
exports.shouldShowAddTotalButton = shouldShowAddTotalButton;
function getFirstMeasureIndex(headers) {
    var measureOffset = headers.findIndex(function (header) { return MappingHeader_1.isMappingHeaderMeasureItem(header); });
    return measureOffset === -1 ? 0 : measureOffset;
}
exports.getFirstMeasureIndex = getFirstMeasureIndex;
function hasTableColumnTotalEnabled(outputMeasureIndexes, tableColumnIndex, firstMeasureIndex) {
    var index = tableColumnIndex - firstMeasureIndex;
    return outputMeasureIndexes && outputMeasureIndexes.includes(index);
}
exports.hasTableColumnTotalEnabled = hasTableColumnTotalEnabled;
function addMeasureIndex(totals, headers, totalType, tableColumnIndex) {
    var index = tableColumnIndex - getFirstMeasureIndex(headers);
    return totals.map(function (total) {
        if (total.type !== totalType) {
            return total;
        }
        var outputMeasureIndexes = clone(total.outputMeasureIndexes);
        outputMeasureIndexes.push(index);
        outputMeasureIndexes.sort(function (a, b) { return a - b; });
        return __assign({}, total, { outputMeasureIndexes: sortedUniq(outputMeasureIndexes) });
    });
}
exports.addMeasureIndex = addMeasureIndex;
function removeMeasureIndex(totals, headers, totalType, tableColumnIndex) {
    var index = tableColumnIndex - getFirstMeasureIndex(headers);
    return totals.map(function (total) {
        if (total.type !== totalType) {
            return total;
        }
        var outputMeasureIndexes = without(total.outputMeasureIndexes, index);
        return __assign({}, total, { outputMeasureIndexes: outputMeasureIndexes });
    });
}
exports.removeMeasureIndex = removeMeasureIndex;
function getTotalsDefinition(totalsWithValues) {
    var totalsWithoutValues = totalsWithValues.map(function (total) { return omit(total, "values"); });
    return orderTotals(totalsWithoutValues);
}
exports.getTotalsDefinition = getTotalsDefinition;
function shouldShowTotals(headers) {
    if (headers.length < 1) {
        return false;
    }
    var onlyMeasures = headers.every(function (header) {
        return MappingHeader_1.isMappingHeaderMeasureItem(header);
    });
    var onlyAttributes = headers.every(function (header) {
        return MappingHeader_1.isMappingHeaderAttribute(header);
    });
    return !(onlyAttributes || onlyMeasures);
}
exports.shouldShowTotals = shouldShowTotals;
exports.getColumnTotalsFromResultSpec = function (source) {
    return get(source, "dimensions[0].totals", []);
};
exports.default = {
    getColumnTotalsFromResultSpec: exports.getColumnTotalsFromResultSpec,
};
//# sourceMappingURL=utils.js.map
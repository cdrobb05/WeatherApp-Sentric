"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports["default"] = exports.POSITION_SAME_AS_TARGET = void 0;

var _from = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactPortal = require("react-portal");

var _bindAll = _interopRequireDefault(require("lodash/bindAll"));

var _pick = _interopRequireDefault(require("lodash/pick"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _findIndex = _interopRequireDefault(require("lodash/findIndex"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

require("element-closest-polyfill");

var _immutable = require("./immutable");

var _utils = require("../Overlay/utils");

var _domUtilities = require("./domUtilities");

var _constants = require("../core/constants");

// (C) 2007-2020 GoodData Corporation
var events = [{
  name: "click",
  handler: "closeOnOutsideClick",
  target: document
}, {
  name: "mousedown",
  handler: "onDocumentMouseDown",
  target: document,
  requiredProp: "closeOnOutsideClick"
}, {
  name: "goodstrap.scrolled",
  handler: "closeOnParentScroll"
}, {
  name: "goodstrap.drag",
  handler: "closeOnMouseDrag"
}, {
  name: "keydown",
  handler: "closeOnEscape"
}];
var eventProps = events.map(function (event) {
  return event.handler;
});
var ALIGN_TIMEOUT_MS = 10;
var INIT_STATE_ALIGN = -500;
var POSITION_SAME_AS_TARGET = "sameAsTarget";
exports.POSITION_SAME_AS_TARGET = POSITION_SAME_AS_TARGET;

function exceedsThreshold(firstNumber, secondNumber) {
  return Math.abs(firstNumber - secondNumber) > 2;
}

function alignExceedsThreshold(firstAlignment, secondAlignment) {
  return exceedsThreshold(firstAlignment.top, secondAlignment.top) || exceedsThreshold(firstAlignment.left, secondAlignment.left) || exceedsThreshold(firstAlignment.right, secondAlignment.right);
}

var stopPropagation = function stopPropagation(e) {
  e.stopPropagation();
};

var Overlay = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Overlay, _Component);

  function Overlay(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Overlay);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Overlay).call(this, props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "isSameAsTargetPosition", function (positionType) {
      return positionType === POSITION_SAME_AS_TARGET;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "resizeHandler", (0, _debounce["default"])(function () {
      return _this.align();
    }, 100));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "containerRef", (0, _react.createRef)());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "overlayRef", (0, _react.createRef)());
    _this.state = {
      alignment: {
        align: props.alignPoints[0].align,
        left: INIT_STATE_ALIGN,
        top: INIT_STATE_ALIGN,
        right: 0
      }
    };
    _this.isComponentMounted = false;
    _this.clickedInside = false;
    _this.align = _this.align.bind((0, _assertThisInitialized2["default"])(_this));
    _this.onMaskClick = _this.onMaskClick.bind((0, _assertThisInitialized2["default"])(_this));
    (0, _bindAll["default"])((0, _assertThisInitialized2["default"])(_this), events.map(function (event) {
      return event.handler;
    }));

    _this.createPortalNode();

    return _this;
  }

  (0, _createClass2["default"])(Overlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.isComponentMounted = true;
      window.addEventListener("resize", this.resizeHandler);
      this.addListeners(this.props);
      setTimeout(function () {
        _this2.align();
      }, ALIGN_TIMEOUT_MS);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (!(0, _isEqual["default"])((0, _pick["default"])(this.props, eventProps), (0, _pick["default"])(nextProps, eventProps))) {
        this.removeListeners(this.props);
        this.addListeners(nextProps);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var propsChanged = !(0, _immutable.propsEqual)(this.props, nextProps);
      var positionChanged = !(0, _isEqual["default"])(this.state.alignment, nextState.alignment);
      return propsChanged || positionChanged;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this3 = this;

      setTimeout(function () {
        _this3.align();
      }, ALIGN_TIMEOUT_MS);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.isComponentMounted = false;
      window.removeEventListener("resize", this.resizeHandler);
      this.removeListeners(this.props);
      this.removePortalNodeAfterAllTreeUnmount();
    }
  }, {
    key: "onMaskClick",
    value: function onMaskClick(e) {
      if (!this.props.closeOnOutsideClick) {
        e.stopPropagation();
      }
    }
  }, {
    key: "getOverlayStyles",
    value: function getOverlayStyles() {
      var _this$props = this.props,
          alignTo = _this$props.alignTo,
          positionType = _this$props.positionType,
          zIndex = _this$props.zIndex;
      var alignment = this.state.alignment;
      var position = positionType;

      if (this.isSameAsTargetPosition(positionType)) {
        position = (0, _domUtilities.isFixedPosition)(alignTo) ? "fixed" : "absolute";
      }

      return {
        position: position,
        left: alignment.left,
        top: alignment.top,
        zIndex: zIndex
      };
    }
  }, {
    key: "getOverlayClasses",
    value: function getOverlayClasses() {
      return (0, _classnames["default"])(this.props.className, this.getAlignClasses(), {
        "overlay-wrapper": true
      });
    }
    /**
     * Add CSS classes to overlay wrapper, so they can be used
     * for position of arrows and stuff
     */

  }, {
    key: "getAlignClasses",
    value: function getAlignClasses() {
      var align = this.state.alignment.align.split(" ");
      return "target-".concat(align[0], " self-").concat(align[1]);
    }
  }, {
    key: "createPortalNode",
    value: function createPortalNode() {
      this.portalNode = document.createElement("div");
      document.body.appendChild(this.portalNode);
    }
  }, {
    key: "removePortalNodeAfterAllTreeUnmount",
    value: function removePortalNodeAfterAllTreeUnmount() {
      var _this4 = this;

      setTimeout(function () {
        if (_this4.portalNode && document.body.contains(_this4.portalNode)) {
          document.body.removeChild(_this4.portalNode);
        }

        _this4.portalNode = null;
      });
    }
  }, {
    key: "isEventOnParent",
    value: function isEventOnParent(event) {
      var node = this.containerRef.current;
      var eventNode = event.detail && event.detail.node || event.target;
      return eventNode.contains(node);
    }
  }, {
    key: "shouldCloseOnClick",
    value: function shouldCloseOnClick(e) {
      if (!this.isComponentMounted) {
        return false;
      }

      if (!this.isAligned()) {
        return false;
      } // an ignored node has been clicked, always keep the overlay open


      if (this.hasClickedOnIgnoredNode(e)) {
        return false;
      } // non-ignored node clicked, give shouldCloseOnClick the chance
      // to override closing the dialog


      if (!this.props.shouldCloseOnClick(e)) {
        return false;
      }

      return true;
    }
  }, {
    key: "hasClickedOnIgnoredNode",
    value: function hasClickedOnIgnoredNode(e) {
      if (e.defaultPrevented) {
        // Ignore event if it should be prevented (e.q. by click in child component)
        return true;
      }

      var clickedElement = e.target;

      if (this.isElementInChildOverlay(clickedElement) || this.clickedInside) {
        return true;
      }

      var ignoredRefElements = [this.overlayRef.current].concat((0, _toConsumableArray2["default"])(this.props.ignoreClicksOn));
      var clickInsideIgnoredRefElement = ignoredRefElements.some(function (ref) {
        return ref && ref.contains(clickedElement);
      });

      if (clickInsideIgnoredRefElement) {
        return true;
      }

      var clickInsideIgnoredClassElement = this.props.ignoreClicksOnByClass.some(function (selector) {
        return clickedElement.closest(selector);
      });

      if (clickInsideIgnoredClassElement) {
        return true;
      }

      return false;
    }
  }, {
    key: "isAligned",
    value: function isAligned() {
      return this.state.alignment.left !== INIT_STATE_ALIGN && this.state.alignment.top != INIT_STATE_ALIGN;
    } // makes assumption that overlays later in the DOM are child overlays

  }, {
    key: "isElementInChildOverlay",
    value: function isElementInChildOverlay(element) {
      var _this5 = this;

      var overlays = (0, _from["default"])(document.querySelectorAll(".overlay-wrapper"));
      var thisOverlayIndex = (0, _findIndex["default"])(overlays, function (overlay) {
        return overlay === _this5.overlayRef.current;
      });
      return overlays.slice(thisOverlayIndex + 1).some(function (overlay) {
        return overlay.contains(element);
      });
    }
  }, {
    key: "align",
    value: function align() {
      var _this6 = this;

      var _this$props2 = this.props,
          alignPoints = _this$props2.alignPoints,
          alignTo = _this$props2.alignTo,
          positionType = _this$props2.positionType;
      var overlay = this.overlayRef.current;
      if (!alignPoints || !overlay) return;
      var isSameAsTarget = this.isSameAsTargetPosition(positionType);
      var optimalAlign = (0, _utils.getOptimalAlignment)({
        targetRegion: (0, _domUtilities.elementRegion)(alignTo, isSameAsTarget),
        selfRegion: (0, _domUtilities.elementRegion)(overlay),
        alignPoints: alignPoints,
        ignoreScrollOffsets: isSameAsTarget
      });

      if (alignExceedsThreshold(this.state.alignment, optimalAlign.alignment)) {
        this.setState({
          alignment: optimalAlign.alignment
        }, function () {
          _this6.props.onAlign(optimalAlign.alignment);
        });
      } else {
        this.props.onAlign(optimalAlign.alignment);
      }
    }
  }, {
    key: "closeOnParentScroll",
    value: function closeOnParentScroll(e) {
      if (!this.isComponentMounted) {
        return;
      }

      if (this.isEventOnParent(e)) {
        this.props.onClose();
      }
    }
  }, {
    key: "closeOnMouseDrag",
    value: function closeOnMouseDrag() {
      if (!this.isComponentMounted) {
        return;
      }

      this.props.onClose();
    }
  }, {
    key: "closeOnOutsideClick",
    value: function closeOnOutsideClick(e) {
      if (this.shouldCloseOnClick(e)) {
        this.props.onClose();
      }
    }
  }, {
    key: "onDocumentMouseDown",
    value: function onDocumentMouseDown(e) {
      this.clickedInside = this.overlayRef.current.contains(e.target);
    }
  }, {
    key: "closeOnEscape",
    value: function closeOnEscape(e) {
      if (this.isComponentMounted && this.props.closeOnEscape && e.keyCode === _constants.KEY_CODE_ESCAPE) {
        this.props.onClose();
      }
    }
  }, {
    key: "updateListeners",
    value: function updateListeners(method, props) {
      var _this7 = this;

      events.forEach(function (event) {
        if (props[event.handler] || props[event.requiredProp]) {
          var handler = _this7[event.handler];

          if (handler) {
            (event.target || window)["".concat(method, "EventListener")](event.name, handler);
          }
        }
      });
    }
  }, {
    key: "addListeners",
    value: function addListeners(props) {
      this.updateListeners("add", props);
    }
  }, {
    key: "removeListeners",
    value: function removeListeners(props) {
      this.updateListeners("remove", props);
    }
  }, {
    key: "renderMask",
    value: function renderMask() {
      return this.props.isModal ? _react["default"].createElement("div", {
        className: "modalityPlugin-mask modalityPlugin-mask-visible",
        onClick: this.onMaskClick
      }) : false;
    }
  }, {
    key: "render",
    value: function render() {
      // Need stop propagation of events from Portal thats new behavior of react 16
      // https://github.com/facebook/react/issues/11387
      return _react["default"].createElement("span", {
        className: "s-portal-scroll-anchor",
        ref: this.containerRef
      }, _react["default"].createElement(_reactPortal.Portal, {
        isOpen: true,
        node: this.portalNode
      }, _react["default"].createElement("div", {
        className: this.props.containerClassName,
        onClick: this.props.onClick,
        onMouseOver: this.props.onMouseOver,
        onMouseUp: this.props.onMouseUp
      }, this.renderMask(), _react["default"].createElement("div", {
        ref: this.overlayRef,
        style: this.getOverlayStyles(),
        className: this.getOverlayClasses()
      }, this.props.children))));
    }
  }]);
  return Overlay;
}(_react.Component);

exports["default"] = Overlay;
(0, _defineProperty2["default"])(Overlay, "propTypes", {
  alignPoints: _propTypes["default"].arrayOf(_propTypes["default"].shape({
    align: _propTypes["default"].string.isRequired,
    offset: _propTypes["default"].shape({
      x: _propTypes["default"].number,
      y: _propTypes["default"].number
    })
  })),
  alignTo: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].object]),
  children: _propTypes["default"].node,
  className: _propTypes["default"].string,
  closeOnMouseDrag: _propTypes["default"].bool,
  closeOnOutsideClick: _propTypes["default"].bool,
  closeOnParentScroll: _propTypes["default"].bool,
  closeOnEscape: _propTypes["default"].bool,

  /**
   * Array of refs where user clicks should be ignored
   * and overlay should not be closed by clicking on them
   */
  ignoreClicksOn: _propTypes["default"].array,
  ignoreClicksOnByClass: _propTypes["default"].array,
  isModal: _propTypes["default"].bool,
  onAlign: _propTypes["default"].func,
  onClose: _propTypes["default"].func,

  /**
   * positionType: sameAsTarget
   * Overlay's position is calculated based on the target's position type
   * If target's position is fixed,
   *  - the overlay will also be in fixed position (position: fixed)
   *  - the overlay's offsets (top, left) will be calculated based on
   *    target's offsets (top, left), without scroll offsets
   */
  positionType: _propTypes["default"].oneOf(["absolute", "fixed", POSITION_SAME_AS_TARGET]),
  shouldCloseOnClick: _propTypes["default"].func,
  onClick: _propTypes["default"].func,
  onMouseOver: _propTypes["default"].func,
  onMouseUp: _propTypes["default"].func,
  zIndex: _propTypes["default"].number
});
(0, _defineProperty2["default"])(Overlay, "defaultProps", {
  alignPoints: _utils.DEFAULT_ALIGN_POINTS,
  alignTo: "body",
  children: false,
  className: "",
  containerClassName: "",
  closeOnMouseDrag: false,
  closeOnOutsideClick: false,
  closeOnParentScroll: false,
  closeOnEscape: false,
  ignoreClicksOn: [],
  ignoreClicksOnByClass: [],
  isModal: false,
  onAlign: function onAlign() {},
  onClose: function onClose() {},
  positionType: "absolute",
  shouldCloseOnClick: function shouldCloseOnClick() {
    return true;
  },
  onClick: stopPropagation,
  onMouseOver: stopPropagation,
  onMouseUp: stopPropagation,
  zIndex: null
});
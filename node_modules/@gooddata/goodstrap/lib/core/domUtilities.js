"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.elementRegion = exports.isFixedPosition = exports.region = exports.removeFromDom = void 0;

// (C) 2007-2020 GoodData Corporation

/**
 * Removes the element specifed from the DOM
 * @param {HTMLElement} element
 */
var removeFromDom = function removeFromDom(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
};
/**
 * Returns bounding rectangle of specified elements
 * in local (relative to offset parent of element)
 * coordinate space
 *
 * @param  {HTMLElement}  element
 * @param  {boolean}      ignoreScrollOffsets
 * @param  {Object}       windowObject - use for unit test only
 * @return {Object}       Bounding rectangle
 */


exports.removeFromDom = removeFromDom;

var region = function region(element, ignoreScrollOffsets) {
  var windowObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;
  var boundingRect = element.getBoundingClientRect();
  var offsetLeft = (ignoreScrollOffsets ? 0 : windowObject.pageXOffset) + boundingRect.left;
  var offsetTop = (ignoreScrollOffsets ? 0 : windowObject.pageYOffset) + boundingRect.top;
  var width = element.offsetWidth || boundingRect.width;
  var height = element.offsetHeight || boundingRect.height;
  return {
    left: offsetLeft,
    top: offsetTop,
    width: width,
    height: height,
    bottom: offsetTop + height,
    right: offsetLeft + width
  };
};
/**
 * Returns a value indicating whether the element
 * specified is mounted to the DOM
 * @param {HTMLElement} element
 * @returns {boolean}
 */


exports.region = region;

var isInDom = function isInDom(element) {
  var elem = element;

  while (elem) {
    if (elem === document) {
      return true;
    }

    elem = elem.parentNode;
  }

  return false;
};
/**
 * Returns a value indicating whether the element
 * specified is fixed position
 * or is contained in fixed position element
 * @param {HTMLElement|string} element
 * @returns {boolean}
 */


var isFixedPosition = function isFixedPosition(element) {
  var elem = typeof element === "string" ? document.querySelector(element) : element;

  if (!elem) {
    return {};
  }

  while (elem) {
    if (elem.style && elem.style.position === "fixed") {
      return true;
    }

    elem = elem.parentNode;
  }

  return false;
};
/**
 * Returns bounding rectangle of specified elements
 * in local (relative to offset parent of element)
 * coordinate space
 * @param {HTMLElement|string} elementOrSelector
 */


exports.isFixedPosition = isFixedPosition;

var elementRegion = function elementRegion(elementOrSelector, getRegionBasedOnPosition) {
  var elem = typeof elementOrSelector === "string" ? document.querySelector(elementOrSelector) : elementOrSelector;

  if (!elem) {
    return {};
  }

  if (isInDom(elem)) {
    // If element is contained within DOM, we can simply measure it as is
    return region(elem, getRegionBasedOnPosition && isFixedPosition(elem));
  } // In case the element is not yet in DOM
  // we have to append it first to be able to measure it.
  // Since we don't want to overwrite any CSS properties previously defined
  // on element, we have to back the old CSS properties up.


  var originalCss = {
    position: elem.style.position,
    visibility: elem.style.visibility
  }; // Append the element to DOM and ensure its not visible neither it causes
  // document reflow

  elem.style.position = "absolute";
  elem.style.visibility = "hidden";
  document.body.appendChild(elem); // Measure the element now

  var reg = region(elem); // Restore previous state as much as possible

  removeFromDom(elem);
  elem.style.position = originalCss.position;
  elem.style.visibility = originalCss.visibility;
  return reg;
};

exports.elementRegion = elementRegion;
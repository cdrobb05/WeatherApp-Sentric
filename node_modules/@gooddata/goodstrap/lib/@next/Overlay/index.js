"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports["default"] = exports.POSITION_SAME_AS_TARGET = void 0;

var _from = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactPortal = require("react-portal");

var _bindAll = _interopRequireDefault(require("lodash/bindAll"));

var _pick = _interopRequireDefault(require("lodash/pick"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _findIndex = _interopRequireDefault(require("lodash/findIndex"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

var _immutable = require("../../core/immutable");

var _domUtilities = require("../../core/domUtilities");

var _utils = require("./utils");

var _constants = require("../../core/constants");

require("element-closest-polyfill");

var _noop = _interopRequireDefault(require("lodash/noop"));

// (C) 2007-2020 GoodData Corporation
var events = [{
  name: "click",
  handler: "closeOnOutsideClick",
  target: document
}, {
  name: "mousedown",
  handler: "onDocumentMouseDown",
  target: document,
  requiredProp: "closeOnOutsideClick"
}, {
  name: "goodstrap.scrolled",
  handler: "closeOnParentScroll"
}, {
  name: "goodstrap.drag",
  handler: "closeOnMouseDrag"
}, {
  name: "keydown",
  handler: "closeOnEscape"
}];
var eventProps = events.map(function (event) {
  return event.handler;
});
var ALIGN_TIMEOUT_MS = 10;
var POSITION_SAME_AS_TARGET = "sameAsTarget";
exports.POSITION_SAME_AS_TARGET = POSITION_SAME_AS_TARGET;

function exceedsThreshold(firstNumber, secondNumber) {
  return Math.abs(firstNumber - secondNumber) > 2;
}

function alignExceedsThreshold(firstAlignment, secondAlignment) {
  return exceedsThreshold(firstAlignment.top, secondAlignment.top) || exceedsThreshold(firstAlignment.left, secondAlignment.left) || exceedsThreshold(firstAlignment.right, secondAlignment.right);
}

var stopPropagation = function stopPropagation(e) {
  return e.stopPropagation();
};

var Overlay = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Overlay, _Component);

  function Overlay(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Overlay);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Overlay).call(this, props));
    _this.overlayRef = (0, _react.createRef)();
    _this.containerRef = (0, _react.createRef)();
    _this.resizeHandler = (0, _debounce["default"])(function () {
      return _this.align();
    }, 100);
    _this.portalNode = null;

    _this.align = function () {
      var _this$props = _this.props,
          alignPoints = _this$props.alignPoints,
          alignTo = _this$props.alignTo,
          positionType = _this$props.positionType;
      var overlay = _this.overlayRef.current;

      if (!alignPoints || !overlay) {
        return;
      }

      var isSameAsTarget = _this.isSameAsTargetPosition(positionType);

      var optimalAlign = (0, _utils.getOptimalAlignment)({
        targetRegion: (0, _domUtilities.elementRegion)(alignTo, isSameAsTarget),
        selfRegion: (0, _domUtilities.elementRegion)(overlay),
        alignPoints: alignPoints,
        ignoreScrollOffsets: isSameAsTarget
      });

      if (alignExceedsThreshold(_this.state.alignment, optimalAlign.alignment)) {
        _this.setState({
          alignment: optimalAlign.alignment
        }, function () {
          _this.props.onAlign(optimalAlign.alignment);
        });
      } else {
        _this.props.onAlign(optimalAlign.alignment);
      }
    };

    _this.closeOnParentScroll = function (e) {
      if (!_this.isComponentMounted) {
        return;
      }

      if (_this.isEventOnParent(e)) {
        _this.props.onClose();
      }
    };

    _this.closeOnMouseDrag = function () {
      if (!_this.isComponentMounted) {
        return;
      }

      _this.props.onClose();
    };

    _this.closeOnOutsideClick = function (e) {
      if (_this.shouldCloseOnClick(e)) {
        _this.props.onClose();
      }
    };

    _this.onMaskClick = function (e) {
      if (!_this.props.closeOnOutsideClick) {
        e.stopPropagation();
      }
    };

    _this.getOverlayStyles = function () {
      var _this$props2 = _this.props,
          alignTo = _this$props2.alignTo,
          positionType = _this$props2.positionType,
          zIndex = _this$props2.zIndex;
      var alignment = _this.state.alignment;
      var position = _this.isSameAsTargetPosition(positionType) ? (0, _domUtilities.isFixedPosition)(alignTo) ? "fixed" : "absolute" : positionType;
      return {
        position: position,
        left: alignment.left,
        top: alignment.top,
        zIndex: zIndex
      };
    };

    _this.getOverlayClasses = function () {
      return (0, _classnames["default"])(_this.props.className, _this.getAlignClasses(), {
        "overlay-wrapper": true
      });
    };
    /**
     * Add CSS classes to overlay wrapper, so they can be used
     * for position of arrows and stuff
     */


    _this.getAlignClasses = function () {
      var align = _this.state.alignment.align.split(" ");

      return "target-".concat(align[0], " self-").concat(align[1]);
    };

    _this.isSameAsTargetPosition = function (positionType) {
      return positionType === POSITION_SAME_AS_TARGET;
    };

    _this.isEventOnParent = function (event) {
      var node = _this.containerRef.current;
      var eventNode = event.detail && event.detail.node || event.target;
      return eventNode.contains(node);
    };

    _this.shouldCloseOnClick = function (e) {
      if (!_this.isComponentMounted) {
        return false;
      } // an ignored node has been clicked, always keep the overlay open


      if (_this.hasClickedOnIgnoredNode(e)) {
        return false;
      } // non-ignored node clicked, give shouldCloseOnClick the chance
      // to override closing the dialog


      if (!_this.props.shouldCloseOnClick(e)) {
        return false;
      }

      return true;
    };

    _this.hasClickedOnIgnoredNode = function (e) {
      if (e.defaultPrevented) {
        // Ignore event if it should be prevented (e.q. by click in child component)
        return true;
      }

      var clickedElement = e.target;

      if (_this.isElementInChildOverlay(clickedElement) || _this.clickedInside) {
        return true;
      }

      var ignoredRefElements = [_this.overlayRef.current].concat((0, _toConsumableArray2["default"])(_this.props.ignoreClicksOn));
      var clickInsideIgnoredRefElement = ignoredRefElements.some(function (ref) {
        return ref && ref.contains(clickedElement);
      });

      if (clickInsideIgnoredRefElement) {
        return true;
      }

      var clickInsideIgnoredClassElement = _this.props.ignoreClicksOnByClass.some(function (selector) {
        return clickedElement.closest(selector);
      });

      if (clickInsideIgnoredClassElement) {
        return true;
      }

      return false;
    }; // makes assumption that overlays later in the DOM are child overlays


    _this.isElementInChildOverlay = function (element) {
      var overlays = (0, _from["default"])(document.querySelectorAll(".overlay-wrapper"));
      var thisOverlayIndex = (0, _findIndex["default"])(overlays, function (overlay) {
        return overlay === _this.overlayRef.current;
      });
      return overlays.slice(thisOverlayIndex + 1).some(function (overlay) {
        return overlay.contains(element);
      });
    };

    _this.updateListeners = function (method, props) {
      events.forEach(function (event) {
        if (props[event.handler] || props[event.requiredProp]) {
          var handler = _this[event.handler];

          if (handler) {
            (event.target || window)["".concat(method, "EventListener")](event.name, handler);
          }
        }
      });
    };

    _this.addListeners = function (props) {
      _this.updateListeners("add", props);
    };

    _this.removeListeners = function (props) {
      _this.updateListeners("remove", props);
    };

    _this.renderMask = function () {
      return _this.props.isModal ? _react["default"].createElement("div", {
        className: "modalityPlugin-mask modalityPlugin-mask-visible",
        onClick: _this.onMaskClick
      }) : false;
    };

    _this.state = {
      alignment: {
        align: props.alignPoints[0].align,
        left: -500,
        top: -500,
        right: 0
      }
    };
    _this.isComponentMounted = false; // TODO: WHY?

    _this.clickedInside = false;
    (0, _bindAll["default"])((0, _assertThisInitialized2["default"])(_this), events.map(function (event) {
      return event.handler;
    }));

    _this.createPortalNode();

    return _this;
  }

  (0, _createClass2["default"])(Overlay, [{
    key: "render",
    value: function render() {
      // Need stop propagation of events from Portal thats new behavior of react 16
      // https://github.com/facebook/react/issues/11387
      return _react["default"].createElement("span", {
        className: "s-portal-scroll-anchor",
        ref: this.containerRef
      }, _react["default"].createElement(_reactPortal.Portal, {
        isOpen: true,
        node: this.portalNode
      }, _react["default"].createElement("div", {
        className: this.props.containerClassName,
        onClick: this.props.onClick,
        onMouseOver: this.props.onMouseOver,
        onMouseUp: this.props.onMouseUp
      }, this.renderMask(), _react["default"].createElement("div", {
        ref: this.overlayRef,
        style: this.getOverlayStyles(),
        className: this.getOverlayClasses()
      }, this.props.children))));
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.isComponentMounted = true;
      window.addEventListener("resize", this.resizeHandler);
      this.addListeners(this.props);
      setTimeout(function () {
        _this2.align();
      }, ALIGN_TIMEOUT_MS);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (!(0, _isEqual["default"])((0, _pick["default"])(this.props, eventProps), (0, _pick["default"])(nextProps, eventProps))) {
        this.removeListeners(this.props);
        this.addListeners(nextProps);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var propsChanged = !(0, _immutable.propsEqual)(this.props, nextProps);
      var positionChanged = !(0, _isEqual["default"])(this.state.alignment, nextState.alignment);
      return propsChanged || positionChanged;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this3 = this;

      setTimeout(function () {
        _this3.align();
      }, ALIGN_TIMEOUT_MS);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.isComponentMounted = false;
      window.removeEventListener("resize", this.resizeHandler);
      this.removeListeners(this.props);
      this.removePortalNodeAfterAllTreeUnmount();
    }
  }, {
    key: "createPortalNode",
    value: function createPortalNode() {
      this.portalNode = document.createElement("div");
      document.body.appendChild(this.portalNode);
    }
  }, {
    key: "removePortalNodeAfterAllTreeUnmount",
    value: function removePortalNodeAfterAllTreeUnmount() {
      var _this4 = this;

      setTimeout(function () {
        if (_this4.portalNode && document.body.contains(_this4.portalNode)) {
          document.body.removeChild(_this4.portalNode);
        }

        _this4.portalNode = null;
      });
    }
  }, {
    key: "onDocumentMouseDown",
    value: function onDocumentMouseDown(e) {
      this.clickedInside = this.overlayRef.current.contains(e.target);
    }
  }, {
    key: "closeOnEscape",
    value: function closeOnEscape(e) {
      if (this.isComponentMounted && this.props.closeOnEscape && e.keyCode === _constants.KEY_CODE_ESCAPE) {
        this.props.onClose();
      }
    }
  }]);
  return Overlay;
}(_react.Component);

exports["default"] = Overlay;
Overlay.defaultProps = {
  alignPoints: _utils.DEFAULT_ALIGN_POINTS,
  alignTo: "body",
  containerClassName: "",
  positionType: "absolute",
  ignoreClicksOn: [],
  ignoreClicksOnByClass: [],
  shouldCloseOnClick: function shouldCloseOnClick() {
    return true;
  },
  onClick: stopPropagation,
  onMouseOver: stopPropagation,
  onMouseUp: stopPropagation,
  onAlign: _noop["default"]
};
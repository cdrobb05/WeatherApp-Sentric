"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.getOptimalAlignmentForRegion = getOptimalAlignmentForRegion;
exports.getOptimalAlignment = getOptimalAlignment;
exports.DEFAULT_ALIGN_POINTS = void 0;

var _mapValues = _interopRequireDefault(require("lodash/mapValues"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _domUtilities = require("../../core/domUtilities");

// (C) 2007-2020 GoodData Corporation
var ALIGN_RATIOS_X = {
  l: 0,
  r: 1,
  c: 0.5
};
var ALIGN_RATIOS_Y = {
  t: 0,
  b: 1,
  c: 0.5
};
var DEFAULT_OFFSET_VALUES = {
  x: 0,
  y: 0
};
var DEFAULT_ALIGN_POINTS = [{
  align: "cc cc",
  offset: {
    x: 0,
    y: 0
  }
}];
exports.DEFAULT_ALIGN_POINTS = DEFAULT_ALIGN_POINTS;
var FULLY_HIDDEN_ALIGNMENT = {
  alignment: {
    left: 0,
    top: 0,
    right: 0,
    align: DEFAULT_ALIGN_POINTS[0].align
  },
  visiblePart: -1
};

function getDefaultViewportRegion(ignoreScrollOffsets) {
  var region = (0, _domUtilities.elementRegion)(document.body);
  return {
    top: ignoreScrollOffsets ? 0 : document.documentElement.scrollTop,
    left: ignoreScrollOffsets ? 0 : document.documentElement.scrollLeft,
    width: region.width,
    height: region.height
  };
}

function getDefaultDocumentRegion() {
  return {
    top: 0,
    left: 0,
    height: document.documentElement.scrollHeight,
    width: document.documentElement.scrollWidth
  };
}

function getAlignRatios(coordinatesString) {
  if (!(coordinatesString[0] in ALIGN_RATIOS_Y) || !(coordinatesString[1] in ALIGN_RATIOS_X)) {
    throw new Error("Invalid point specification: ".concat(coordinatesString));
  }

  return {
    x: ALIGN_RATIOS_X[coordinatesString[1]],
    y: ALIGN_RATIOS_Y[coordinatesString[0]]
  };
}

function getAlignPointRatios(alignPointAlign) {
  var alignPointPositions = alignPointAlign.split(" ");
  return {
    target: getAlignRatios(alignPointPositions[0]),
    self: getAlignRatios(alignPointPositions[1])
  };
}

function getRegionOffset(region, ratio) {
  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return {
    x: region.width * ratio.x * direction,
    y: region.height * ratio.y * direction
  };
}

function getAlignPointOffset(alignPointOffset) {
  return (0, _merge["default"])({}, DEFAULT_OFFSET_VALUES, alignPointOffset);
}

function addOffset(position, offset) {
  return {
    x: position.x + offset.x,
    y: position.y + offset.y
  };
}

function getGlobalOffset(target) {
  return {
    x: target.left,
    y: target.top
  };
}
/**
 * Get left-top coordinates of a child summing up offsets of a child,
 * align points and left-top coordinates of target region
 */


function getGlobalPosition(targetRegion, selfRegion, alignPoint) {
  var alignRatio = getAlignPointRatios(alignPoint.align);
  var targetRegionOffset = getRegionOffset(targetRegion, alignRatio.target);
  var selfRegionOffset = getRegionOffset(selfRegion, alignRatio.self, -1);
  var alignPointOffset = getAlignPointOffset(alignPoint.offset);
  var cumulativeOffset = addOffset(alignPointOffset, addOffset(targetRegionOffset, selfRegionOffset));
  var globalOffset = getGlobalOffset(targetRegion);
  return addOffset(globalOffset, cumulativeOffset);
}
/**
 * Move region to position specified by anchor point,
 * using its left-top coordinates
 */


function moveRegionToPosition(region, anchorPoint) {
  return (0, _merge["default"])({}, region, {
    left: anchorPoint.x,
    top: anchorPoint.y,
    width: region.width,
    height: region.height
  });
}
/**
 * Move self region to new position using its left-top coordinates
 */


function getPositionedSelfRegion(_ref) {
  var targetRegion = _ref.targetRegion,
      selfRegion = _ref.selfRegion,
      alignPoint = _ref.alignPoint;
  var globalPosition = getGlobalPosition(targetRegion, selfRegion, alignPoint);
  return moveRegionToPosition(selfRegion, globalPosition);
}
/**
 * Get fraction of visible area
 */


function getRatioOfVisibleRegion(boundaryRegion, region) {
  var maximalVisibleArea = region.width * region.height;

  if (maximalVisibleArea === 0) {
    return 0;
  }

  var leftBorder = Math.max(boundaryRegion.left, region.left);
  var rightBorder = Math.min(boundaryRegion.left + boundaryRegion.width, region.left + region.width);
  var topBorder = Math.max(boundaryRegion.top, region.top);
  var bottomBorder = Math.min(boundaryRegion.top + boundaryRegion.height, region.top + region.height);
  var visibleWidth = Math.max(rightBorder - leftBorder, 0);
  var visibleHeight = Math.max(bottomBorder - topBorder, 0);
  var visibleArea = visibleWidth * visibleHeight;
  var visibleRatio = visibleArea / maximalVisibleArea;
  return Math.max(0, visibleRatio);
}

function isFullyVisible(alignment) {
  return alignment.visiblePart === 1;
}

function isFullyHidden(alignment) {
  return alignment.visiblePart === 0;
}
/**
 * Calculate most visible alignment of self region which
 * would be positioned to target region using specified
 * align points
 */


function getOptimalAlignmentForRegion(_ref2) {
  var boundaryRegion = _ref2.boundaryRegion,
      targetRegion = _ref2.targetRegion,
      selfRegion = _ref2.selfRegion,
      alignPoints = _ref2.alignPoints;
  var mostVisibleAlignment = FULLY_HIDDEN_ALIGNMENT; // tslint:disable-next-line prefer-for-of

  for (var i = 0; i < alignPoints.length; i += 1) {
    var positionedSelfRegion = getPositionedSelfRegion({
      alignPoint: alignPoints[i],
      targetRegion: targetRegion,
      selfRegion: selfRegion
    });
    var visiblePart = getRatioOfVisibleRegion(boundaryRegion, positionedSelfRegion);

    if (visiblePart > mostVisibleAlignment.visiblePart) {
      var coordinates = {
        left: positionedSelfRegion.left,
        top: positionedSelfRegion.top,
        right: boundaryRegion.left + boundaryRegion.width - positionedSelfRegion.left - selfRegion.width
      };
      mostVisibleAlignment = {
        alignment: (0, _merge["default"])((0, _mapValues["default"])(coordinates, Math.floor), {
          align: alignPoints[i].align
        }),
        visiblePart: visiblePart
      };
    }

    if (isFullyVisible(mostVisibleAlignment)) {
      return mostVisibleAlignment;
    }
  }

  return mostVisibleAlignment;
}
/**
 * Calculate optimal alignment of self region
 * using viewport boundaries. Try to position
 * using body boundaries if the region
 * is fully hidden in the viewport
 */


function getOptimalAlignment(_ref3) {
  var targetRegion = _ref3.targetRegion,
      selfRegion = _ref3.selfRegion,
      ignoreScrollOffsets = _ref3.ignoreScrollOffsets,
      alignPoints = _ref3.alignPoints,
      _ref3$getViewportRegi = _ref3.getViewportRegion,
      getViewportRegion = _ref3$getViewportRegi === void 0 ? getDefaultViewportRegion : _ref3$getViewportRegi,
      _ref3$getDocumentRegi = _ref3.getDocumentRegion,
      getDocumentRegion = _ref3$getDocumentRegi === void 0 ? getDefaultDocumentRegion : _ref3$getDocumentRegi;
  var optimalAlign = getOptimalAlignmentForRegion({
    boundaryRegion: getViewportRegion(ignoreScrollOffsets),
    targetRegion: targetRegion,
    selfRegion: selfRegion,
    alignPoints: alignPoints
  });

  if (isFullyHidden(optimalAlign)) {
    optimalAlign = getOptimalAlignmentForRegion({
      boundaryRegion: getDocumentRegion(),
      targetRegion: targetRegion,
      selfRegion: selfRegion,
      alignPoints: alignPoints
    });
  }

  return optimalAlign;
}